// Generated by `wit-bindgen` 0.24.0. DO NOT EDIT!
// Options used:
#[allow(dead_code)]
pub mod component {
  #[allow(dead_code)]
  pub mod usb {
    #[allow(dead_code, clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum EndpointDirection {
        In,
        Out,
      }
      impl ::core::fmt::Debug for EndpointDirection {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            EndpointDirection::In => {
              f.debug_tuple("EndpointDirection::In").finish()
            }
            EndpointDirection::Out => {
              f.debug_tuple("EndpointDirection::Out").finish()
            }
          }
        }
      }

      impl EndpointDirection{
        pub(crate) unsafe fn _lift(val: u8) -> EndpointDirection{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => EndpointDirection::In,
            1 => EndpointDirection::Out,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum EndpointTransferType {
        Control,
        Isochronous,
        Bulk,
        Interrupt,
      }
      impl ::core::fmt::Debug for EndpointTransferType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            EndpointTransferType::Control => {
              f.debug_tuple("EndpointTransferType::Control").finish()
            }
            EndpointTransferType::Isochronous => {
              f.debug_tuple("EndpointTransferType::Isochronous").finish()
            }
            EndpointTransferType::Bulk => {
              f.debug_tuple("EndpointTransferType::Bulk").finish()
            }
            EndpointTransferType::Interrupt => {
              f.debug_tuple("EndpointTransferType::Interrupt").finish()
            }
          }
        }
      }

      impl EndpointTransferType{
        pub(crate) unsafe fn _lift(val: u8) -> EndpointTransferType{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => EndpointTransferType::Control,
            1 => EndpointTransferType::Isochronous,
            2 => EndpointTransferType::Bulk,
            3 => EndpointTransferType::Interrupt,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum EndpointSyncType {
        NoSync,
        Async,
        Adaptive,
        Synchronous,
      }
      impl ::core::fmt::Debug for EndpointSyncType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            EndpointSyncType::NoSync => {
              f.debug_tuple("EndpointSyncType::NoSync").finish()
            }
            EndpointSyncType::Async => {
              f.debug_tuple("EndpointSyncType::Async").finish()
            }
            EndpointSyncType::Adaptive => {
              f.debug_tuple("EndpointSyncType::Adaptive").finish()
            }
            EndpointSyncType::Synchronous => {
              f.debug_tuple("EndpointSyncType::Synchronous").finish()
            }
          }
        }
      }

      impl EndpointSyncType{
        pub(crate) unsafe fn _lift(val: u8) -> EndpointSyncType{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => EndpointSyncType::NoSync,
            1 => EndpointSyncType::Async,
            2 => EndpointSyncType::Adaptive,
            3 => EndpointSyncType::Synchronous,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum EndpointUsageType {
        Data,
        Feedback,
        FeedbackData,
        Reserved,
      }
      impl ::core::fmt::Debug for EndpointUsageType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            EndpointUsageType::Data => {
              f.debug_tuple("EndpointUsageType::Data").finish()
            }
            EndpointUsageType::Feedback => {
              f.debug_tuple("EndpointUsageType::Feedback").finish()
            }
            EndpointUsageType::FeedbackData => {
              f.debug_tuple("EndpointUsageType::FeedbackData").finish()
            }
            EndpointUsageType::Reserved => {
              f.debug_tuple("EndpointUsageType::Reserved").finish()
            }
          }
        }
      }

      impl EndpointUsageType{
        pub(crate) unsafe fn _lift(val: u8) -> EndpointUsageType{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => EndpointUsageType::Data,
            1 => EndpointUsageType::Feedback,
            2 => EndpointUsageType::FeedbackData,
            3 => EndpointUsageType::Reserved,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct Version {
        pub major: u8,
        pub minor: u8,
        pub subminor: u8,
      }
      impl ::core::fmt::Debug for Version {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Version").field("major", &self.major).field("minor", &self.minor).field("subminor", &self.subminor).finish()
        }
      }
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum Speed {
        Unknown,
        Low,
        Full,
        High,
        Super,
        Superplus,
      }
      impl ::core::fmt::Debug for Speed {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Speed::Unknown => {
              f.debug_tuple("Speed::Unknown").finish()
            }
            Speed::Low => {
              f.debug_tuple("Speed::Low").finish()
            }
            Speed::Full => {
              f.debug_tuple("Speed::Full").finish()
            }
            Speed::High => {
              f.debug_tuple("Speed::High").finish()
            }
            Speed::Super => {
              f.debug_tuple("Speed::Super").finish()
            }
            Speed::Superplus => {
              f.debug_tuple("Speed::Superplus").finish()
            }
          }
        }
      }

      impl Speed{
        pub(crate) unsafe fn _lift(val: u8) -> Speed{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => Speed::Unknown,
            1 => Speed::Low,
            2 => Speed::Full,
            3 => Speed::High,
            4 => Speed::Super,
            5 => Speed::Superplus,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum DeviceHandleError {
        InvalidParam,
        Timeout,
        Pipe,
        Overflow,
        NoDevice,
        Io,
      }
      impl DeviceHandleError{
        pub fn name(&self) -> &'static str {
          match self {
            DeviceHandleError::InvalidParam => "invalid-param",
            DeviceHandleError::Timeout => "timeout",
            DeviceHandleError::Pipe => "pipe",
            DeviceHandleError::Overflow => "overflow",
            DeviceHandleError::NoDevice => "no-device",
            DeviceHandleError::Io => "io",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            DeviceHandleError::InvalidParam => "",
            DeviceHandleError::Timeout => "",
            DeviceHandleError::Pipe => "",
            DeviceHandleError::Overflow => "",
            DeviceHandleError::NoDevice => "",
            DeviceHandleError::Io => "",
          }
        }
      }
      impl ::core::fmt::Debug for DeviceHandleError{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("DeviceHandleError")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for DeviceHandleError{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }

      impl std::error::Error for DeviceHandleError {}

      impl DeviceHandleError{
        pub(crate) unsafe fn _lift(val: u8) -> DeviceHandleError{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => DeviceHandleError::InvalidParam,
            1 => DeviceHandleError::Timeout,
            2 => DeviceHandleError::Pipe,
            3 => DeviceHandleError::Overflow,
            4 => DeviceHandleError::NoDevice,
            5 => DeviceHandleError::Io,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      pub type Duration = u64;
      #[derive(Clone, Copy)]
      pub enum PrimaryLanguage {
        Afrikaans,
        Albanian,
        Arabic,
        Armenian,
        Assamese,
        Azeri,
        Basque,
        Belarussian,
        Bengali,
        Bulgarian,
        Burmese,
        Catalan,
        Chinese,
        Croatian,
        Czech,
        Danish,
        Dutch,
        English,
        Estonian,
        Faeroese,
        Farsi,
        Finnish,
        French,
        Georgian,
        German,
        Greek,
        Gujarati,
        Hebrew,
        Hindi,
        Hungarian,
        Icelandic,
        Indonesian,
        Italian,
        Japanese,
        Kannada,
        Kashmiri,
        Kazakh,
        Konkani,
        Korean,
        Latvian,
        Lithuanian,
        Macedonian,
        Malay,
        Malayalam,
        Manipuri,
        Marathi,
        Nepali,
        Norwegian,
        Oriya,
        Polish,
        Portuguese,
        Punjabi,
        Romanian,
        Russian,
        Sanskrit,
        Serbian,
        Sindhi,
        Slovak,
        Slovenian,
        Spanish,
        Sutu,
        Swahili,
        Swedish,
        Tamil,
        Tatar,
        Telugu,
        Thai,
        Turkish,
        Ukrainian,
        Urdu,
        Uzbek,
        Vietnamese,
        Hid,
        Other(u16),
      }
      impl ::core::fmt::Debug for PrimaryLanguage {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            PrimaryLanguage::Afrikaans => {
              f.debug_tuple("PrimaryLanguage::Afrikaans").finish()
            }
            PrimaryLanguage::Albanian => {
              f.debug_tuple("PrimaryLanguage::Albanian").finish()
            }
            PrimaryLanguage::Arabic => {
              f.debug_tuple("PrimaryLanguage::Arabic").finish()
            }
            PrimaryLanguage::Armenian => {
              f.debug_tuple("PrimaryLanguage::Armenian").finish()
            }
            PrimaryLanguage::Assamese => {
              f.debug_tuple("PrimaryLanguage::Assamese").finish()
            }
            PrimaryLanguage::Azeri => {
              f.debug_tuple("PrimaryLanguage::Azeri").finish()
            }
            PrimaryLanguage::Basque => {
              f.debug_tuple("PrimaryLanguage::Basque").finish()
            }
            PrimaryLanguage::Belarussian => {
              f.debug_tuple("PrimaryLanguage::Belarussian").finish()
            }
            PrimaryLanguage::Bengali => {
              f.debug_tuple("PrimaryLanguage::Bengali").finish()
            }
            PrimaryLanguage::Bulgarian => {
              f.debug_tuple("PrimaryLanguage::Bulgarian").finish()
            }
            PrimaryLanguage::Burmese => {
              f.debug_tuple("PrimaryLanguage::Burmese").finish()
            }
            PrimaryLanguage::Catalan => {
              f.debug_tuple("PrimaryLanguage::Catalan").finish()
            }
            PrimaryLanguage::Chinese => {
              f.debug_tuple("PrimaryLanguage::Chinese").finish()
            }
            PrimaryLanguage::Croatian => {
              f.debug_tuple("PrimaryLanguage::Croatian").finish()
            }
            PrimaryLanguage::Czech => {
              f.debug_tuple("PrimaryLanguage::Czech").finish()
            }
            PrimaryLanguage::Danish => {
              f.debug_tuple("PrimaryLanguage::Danish").finish()
            }
            PrimaryLanguage::Dutch => {
              f.debug_tuple("PrimaryLanguage::Dutch").finish()
            }
            PrimaryLanguage::English => {
              f.debug_tuple("PrimaryLanguage::English").finish()
            }
            PrimaryLanguage::Estonian => {
              f.debug_tuple("PrimaryLanguage::Estonian").finish()
            }
            PrimaryLanguage::Faeroese => {
              f.debug_tuple("PrimaryLanguage::Faeroese").finish()
            }
            PrimaryLanguage::Farsi => {
              f.debug_tuple("PrimaryLanguage::Farsi").finish()
            }
            PrimaryLanguage::Finnish => {
              f.debug_tuple("PrimaryLanguage::Finnish").finish()
            }
            PrimaryLanguage::French => {
              f.debug_tuple("PrimaryLanguage::French").finish()
            }
            PrimaryLanguage::Georgian => {
              f.debug_tuple("PrimaryLanguage::Georgian").finish()
            }
            PrimaryLanguage::German => {
              f.debug_tuple("PrimaryLanguage::German").finish()
            }
            PrimaryLanguage::Greek => {
              f.debug_tuple("PrimaryLanguage::Greek").finish()
            }
            PrimaryLanguage::Gujarati => {
              f.debug_tuple("PrimaryLanguage::Gujarati").finish()
            }
            PrimaryLanguage::Hebrew => {
              f.debug_tuple("PrimaryLanguage::Hebrew").finish()
            }
            PrimaryLanguage::Hindi => {
              f.debug_tuple("PrimaryLanguage::Hindi").finish()
            }
            PrimaryLanguage::Hungarian => {
              f.debug_tuple("PrimaryLanguage::Hungarian").finish()
            }
            PrimaryLanguage::Icelandic => {
              f.debug_tuple("PrimaryLanguage::Icelandic").finish()
            }
            PrimaryLanguage::Indonesian => {
              f.debug_tuple("PrimaryLanguage::Indonesian").finish()
            }
            PrimaryLanguage::Italian => {
              f.debug_tuple("PrimaryLanguage::Italian").finish()
            }
            PrimaryLanguage::Japanese => {
              f.debug_tuple("PrimaryLanguage::Japanese").finish()
            }
            PrimaryLanguage::Kannada => {
              f.debug_tuple("PrimaryLanguage::Kannada").finish()
            }
            PrimaryLanguage::Kashmiri => {
              f.debug_tuple("PrimaryLanguage::Kashmiri").finish()
            }
            PrimaryLanguage::Kazakh => {
              f.debug_tuple("PrimaryLanguage::Kazakh").finish()
            }
            PrimaryLanguage::Konkani => {
              f.debug_tuple("PrimaryLanguage::Konkani").finish()
            }
            PrimaryLanguage::Korean => {
              f.debug_tuple("PrimaryLanguage::Korean").finish()
            }
            PrimaryLanguage::Latvian => {
              f.debug_tuple("PrimaryLanguage::Latvian").finish()
            }
            PrimaryLanguage::Lithuanian => {
              f.debug_tuple("PrimaryLanguage::Lithuanian").finish()
            }
            PrimaryLanguage::Macedonian => {
              f.debug_tuple("PrimaryLanguage::Macedonian").finish()
            }
            PrimaryLanguage::Malay => {
              f.debug_tuple("PrimaryLanguage::Malay").finish()
            }
            PrimaryLanguage::Malayalam => {
              f.debug_tuple("PrimaryLanguage::Malayalam").finish()
            }
            PrimaryLanguage::Manipuri => {
              f.debug_tuple("PrimaryLanguage::Manipuri").finish()
            }
            PrimaryLanguage::Marathi => {
              f.debug_tuple("PrimaryLanguage::Marathi").finish()
            }
            PrimaryLanguage::Nepali => {
              f.debug_tuple("PrimaryLanguage::Nepali").finish()
            }
            PrimaryLanguage::Norwegian => {
              f.debug_tuple("PrimaryLanguage::Norwegian").finish()
            }
            PrimaryLanguage::Oriya => {
              f.debug_tuple("PrimaryLanguage::Oriya").finish()
            }
            PrimaryLanguage::Polish => {
              f.debug_tuple("PrimaryLanguage::Polish").finish()
            }
            PrimaryLanguage::Portuguese => {
              f.debug_tuple("PrimaryLanguage::Portuguese").finish()
            }
            PrimaryLanguage::Punjabi => {
              f.debug_tuple("PrimaryLanguage::Punjabi").finish()
            }
            PrimaryLanguage::Romanian => {
              f.debug_tuple("PrimaryLanguage::Romanian").finish()
            }
            PrimaryLanguage::Russian => {
              f.debug_tuple("PrimaryLanguage::Russian").finish()
            }
            PrimaryLanguage::Sanskrit => {
              f.debug_tuple("PrimaryLanguage::Sanskrit").finish()
            }
            PrimaryLanguage::Serbian => {
              f.debug_tuple("PrimaryLanguage::Serbian").finish()
            }
            PrimaryLanguage::Sindhi => {
              f.debug_tuple("PrimaryLanguage::Sindhi").finish()
            }
            PrimaryLanguage::Slovak => {
              f.debug_tuple("PrimaryLanguage::Slovak").finish()
            }
            PrimaryLanguage::Slovenian => {
              f.debug_tuple("PrimaryLanguage::Slovenian").finish()
            }
            PrimaryLanguage::Spanish => {
              f.debug_tuple("PrimaryLanguage::Spanish").finish()
            }
            PrimaryLanguage::Sutu => {
              f.debug_tuple("PrimaryLanguage::Sutu").finish()
            }
            PrimaryLanguage::Swahili => {
              f.debug_tuple("PrimaryLanguage::Swahili").finish()
            }
            PrimaryLanguage::Swedish => {
              f.debug_tuple("PrimaryLanguage::Swedish").finish()
            }
            PrimaryLanguage::Tamil => {
              f.debug_tuple("PrimaryLanguage::Tamil").finish()
            }
            PrimaryLanguage::Tatar => {
              f.debug_tuple("PrimaryLanguage::Tatar").finish()
            }
            PrimaryLanguage::Telugu => {
              f.debug_tuple("PrimaryLanguage::Telugu").finish()
            }
            PrimaryLanguage::Thai => {
              f.debug_tuple("PrimaryLanguage::Thai").finish()
            }
            PrimaryLanguage::Turkish => {
              f.debug_tuple("PrimaryLanguage::Turkish").finish()
            }
            PrimaryLanguage::Ukrainian => {
              f.debug_tuple("PrimaryLanguage::Ukrainian").finish()
            }
            PrimaryLanguage::Urdu => {
              f.debug_tuple("PrimaryLanguage::Urdu").finish()
            }
            PrimaryLanguage::Uzbek => {
              f.debug_tuple("PrimaryLanguage::Uzbek").finish()
            }
            PrimaryLanguage::Vietnamese => {
              f.debug_tuple("PrimaryLanguage::Vietnamese").finish()
            }
            PrimaryLanguage::Hid => {
              f.debug_tuple("PrimaryLanguage::Hid").finish()
            }
            PrimaryLanguage::Other(e) => {
              f.debug_tuple("PrimaryLanguage::Other").field(e).finish()
            }
          }
        }
      }
      #[derive(Clone, Copy)]
      pub enum SubLanguage {
        Standard,
        Classic,
        Traditional,
        Modern,
        Algeria,
        Argentina,
        Australia,
        Austria,
        Bahrain,
        Belgium,
        Belize,
        Bokmal,
        Bolivia,
        Brazil,
        BruneiDarussalam,
        Canada,
        Caribbean,
        Chile,
        China,
        Colombia,
        CostaRica,
        Cyrillic,
        DominicanRepublic,
        Ecuador,
        Egypt,
        ElSalvador,
        Finland,
        Guatemala,
        Honduras,
        HongKong,
        India,
        Iraq,
        Ireland,
        Jamaica,
        Johab,
        Jordan,
        Kuwait,
        Latin,
        Lebanon,
        Libya,
        Liechtenstein,
        Luxembourg,
        Macau,
        Malaysia,
        Mexico,
        Monaco,
        Morocco,
        Netherlands,
        NewZealand,
        Nicaragua,
        Nynorsk,
        Oman,
        Pakistan,
        Panama,
        Paraguay,
        Peru,
        Philippines,
        PuertoRico,
        Qatar,
        SaudiArabia,
        Singapore,
        SouthAfrica,
        Switzerland,
        Syria,
        Taiwan,
        Trinidad,
        Tunisia,
        UnitedArabEmirates,
        UnitedKingdom,
        UnitedStates,
        Uruguay,
        Venezuela,
        Yemen,
        Zimbabwe,
        UsageDataDescriptor,
        VendorDefined1,
        VendorDefined2,
        VendorDefined3,
        VendorDefined4,
        Other(u16),
      }
      impl ::core::fmt::Debug for SubLanguage {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            SubLanguage::Standard => {
              f.debug_tuple("SubLanguage::Standard").finish()
            }
            SubLanguage::Classic => {
              f.debug_tuple("SubLanguage::Classic").finish()
            }
            SubLanguage::Traditional => {
              f.debug_tuple("SubLanguage::Traditional").finish()
            }
            SubLanguage::Modern => {
              f.debug_tuple("SubLanguage::Modern").finish()
            }
            SubLanguage::Algeria => {
              f.debug_tuple("SubLanguage::Algeria").finish()
            }
            SubLanguage::Argentina => {
              f.debug_tuple("SubLanguage::Argentina").finish()
            }
            SubLanguage::Australia => {
              f.debug_tuple("SubLanguage::Australia").finish()
            }
            SubLanguage::Austria => {
              f.debug_tuple("SubLanguage::Austria").finish()
            }
            SubLanguage::Bahrain => {
              f.debug_tuple("SubLanguage::Bahrain").finish()
            }
            SubLanguage::Belgium => {
              f.debug_tuple("SubLanguage::Belgium").finish()
            }
            SubLanguage::Belize => {
              f.debug_tuple("SubLanguage::Belize").finish()
            }
            SubLanguage::Bokmal => {
              f.debug_tuple("SubLanguage::Bokmal").finish()
            }
            SubLanguage::Bolivia => {
              f.debug_tuple("SubLanguage::Bolivia").finish()
            }
            SubLanguage::Brazil => {
              f.debug_tuple("SubLanguage::Brazil").finish()
            }
            SubLanguage::BruneiDarussalam => {
              f.debug_tuple("SubLanguage::BruneiDarussalam").finish()
            }
            SubLanguage::Canada => {
              f.debug_tuple("SubLanguage::Canada").finish()
            }
            SubLanguage::Caribbean => {
              f.debug_tuple("SubLanguage::Caribbean").finish()
            }
            SubLanguage::Chile => {
              f.debug_tuple("SubLanguage::Chile").finish()
            }
            SubLanguage::China => {
              f.debug_tuple("SubLanguage::China").finish()
            }
            SubLanguage::Colombia => {
              f.debug_tuple("SubLanguage::Colombia").finish()
            }
            SubLanguage::CostaRica => {
              f.debug_tuple("SubLanguage::CostaRica").finish()
            }
            SubLanguage::Cyrillic => {
              f.debug_tuple("SubLanguage::Cyrillic").finish()
            }
            SubLanguage::DominicanRepublic => {
              f.debug_tuple("SubLanguage::DominicanRepublic").finish()
            }
            SubLanguage::Ecuador => {
              f.debug_tuple("SubLanguage::Ecuador").finish()
            }
            SubLanguage::Egypt => {
              f.debug_tuple("SubLanguage::Egypt").finish()
            }
            SubLanguage::ElSalvador => {
              f.debug_tuple("SubLanguage::ElSalvador").finish()
            }
            SubLanguage::Finland => {
              f.debug_tuple("SubLanguage::Finland").finish()
            }
            SubLanguage::Guatemala => {
              f.debug_tuple("SubLanguage::Guatemala").finish()
            }
            SubLanguage::Honduras => {
              f.debug_tuple("SubLanguage::Honduras").finish()
            }
            SubLanguage::HongKong => {
              f.debug_tuple("SubLanguage::HongKong").finish()
            }
            SubLanguage::India => {
              f.debug_tuple("SubLanguage::India").finish()
            }
            SubLanguage::Iraq => {
              f.debug_tuple("SubLanguage::Iraq").finish()
            }
            SubLanguage::Ireland => {
              f.debug_tuple("SubLanguage::Ireland").finish()
            }
            SubLanguage::Jamaica => {
              f.debug_tuple("SubLanguage::Jamaica").finish()
            }
            SubLanguage::Johab => {
              f.debug_tuple("SubLanguage::Johab").finish()
            }
            SubLanguage::Jordan => {
              f.debug_tuple("SubLanguage::Jordan").finish()
            }
            SubLanguage::Kuwait => {
              f.debug_tuple("SubLanguage::Kuwait").finish()
            }
            SubLanguage::Latin => {
              f.debug_tuple("SubLanguage::Latin").finish()
            }
            SubLanguage::Lebanon => {
              f.debug_tuple("SubLanguage::Lebanon").finish()
            }
            SubLanguage::Libya => {
              f.debug_tuple("SubLanguage::Libya").finish()
            }
            SubLanguage::Liechtenstein => {
              f.debug_tuple("SubLanguage::Liechtenstein").finish()
            }
            SubLanguage::Luxembourg => {
              f.debug_tuple("SubLanguage::Luxembourg").finish()
            }
            SubLanguage::Macau => {
              f.debug_tuple("SubLanguage::Macau").finish()
            }
            SubLanguage::Malaysia => {
              f.debug_tuple("SubLanguage::Malaysia").finish()
            }
            SubLanguage::Mexico => {
              f.debug_tuple("SubLanguage::Mexico").finish()
            }
            SubLanguage::Monaco => {
              f.debug_tuple("SubLanguage::Monaco").finish()
            }
            SubLanguage::Morocco => {
              f.debug_tuple("SubLanguage::Morocco").finish()
            }
            SubLanguage::Netherlands => {
              f.debug_tuple("SubLanguage::Netherlands").finish()
            }
            SubLanguage::NewZealand => {
              f.debug_tuple("SubLanguage::NewZealand").finish()
            }
            SubLanguage::Nicaragua => {
              f.debug_tuple("SubLanguage::Nicaragua").finish()
            }
            SubLanguage::Nynorsk => {
              f.debug_tuple("SubLanguage::Nynorsk").finish()
            }
            SubLanguage::Oman => {
              f.debug_tuple("SubLanguage::Oman").finish()
            }
            SubLanguage::Pakistan => {
              f.debug_tuple("SubLanguage::Pakistan").finish()
            }
            SubLanguage::Panama => {
              f.debug_tuple("SubLanguage::Panama").finish()
            }
            SubLanguage::Paraguay => {
              f.debug_tuple("SubLanguage::Paraguay").finish()
            }
            SubLanguage::Peru => {
              f.debug_tuple("SubLanguage::Peru").finish()
            }
            SubLanguage::Philippines => {
              f.debug_tuple("SubLanguage::Philippines").finish()
            }
            SubLanguage::PuertoRico => {
              f.debug_tuple("SubLanguage::PuertoRico").finish()
            }
            SubLanguage::Qatar => {
              f.debug_tuple("SubLanguage::Qatar").finish()
            }
            SubLanguage::SaudiArabia => {
              f.debug_tuple("SubLanguage::SaudiArabia").finish()
            }
            SubLanguage::Singapore => {
              f.debug_tuple("SubLanguage::Singapore").finish()
            }
            SubLanguage::SouthAfrica => {
              f.debug_tuple("SubLanguage::SouthAfrica").finish()
            }
            SubLanguage::Switzerland => {
              f.debug_tuple("SubLanguage::Switzerland").finish()
            }
            SubLanguage::Syria => {
              f.debug_tuple("SubLanguage::Syria").finish()
            }
            SubLanguage::Taiwan => {
              f.debug_tuple("SubLanguage::Taiwan").finish()
            }
            SubLanguage::Trinidad => {
              f.debug_tuple("SubLanguage::Trinidad").finish()
            }
            SubLanguage::Tunisia => {
              f.debug_tuple("SubLanguage::Tunisia").finish()
            }
            SubLanguage::UnitedArabEmirates => {
              f.debug_tuple("SubLanguage::UnitedArabEmirates").finish()
            }
            SubLanguage::UnitedKingdom => {
              f.debug_tuple("SubLanguage::UnitedKingdom").finish()
            }
            SubLanguage::UnitedStates => {
              f.debug_tuple("SubLanguage::UnitedStates").finish()
            }
            SubLanguage::Uruguay => {
              f.debug_tuple("SubLanguage::Uruguay").finish()
            }
            SubLanguage::Venezuela => {
              f.debug_tuple("SubLanguage::Venezuela").finish()
            }
            SubLanguage::Yemen => {
              f.debug_tuple("SubLanguage::Yemen").finish()
            }
            SubLanguage::Zimbabwe => {
              f.debug_tuple("SubLanguage::Zimbabwe").finish()
            }
            SubLanguage::UsageDataDescriptor => {
              f.debug_tuple("SubLanguage::UsageDataDescriptor").finish()
            }
            SubLanguage::VendorDefined1 => {
              f.debug_tuple("SubLanguage::VendorDefined1").finish()
            }
            SubLanguage::VendorDefined2 => {
              f.debug_tuple("SubLanguage::VendorDefined2").finish()
            }
            SubLanguage::VendorDefined3 => {
              f.debug_tuple("SubLanguage::VendorDefined3").finish()
            }
            SubLanguage::VendorDefined4 => {
              f.debug_tuple("SubLanguage::VendorDefined4").finish()
            }
            SubLanguage::Other(e) => {
              f.debug_tuple("SubLanguage::Other").field(e).finish()
            }
          }
        }
      }
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct Language {
        pub id: u16,
        pub primary_language: PrimaryLanguage,
        pub sub_language: SubLanguage,
      }
      impl ::core::fmt::Debug for Language {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Language").field("id", &self.id).field("primary-language", &self.primary_language).field("sub-language", &self.sub_language).finish()
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod descriptors {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type EndpointDirection = super::super::super::component::usb::types::EndpointDirection;
      pub type EndpointTransferType = super::super::super::component::usb::types::EndpointTransferType;
      pub type EndpointSyncType = super::super::super::component::usb::types::EndpointSyncType;
      pub type EndpointUsageType = super::super::super::component::usb::types::EndpointUsageType;
      pub type Version = super::super::super::component::usb::types::Version;
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct EndpointDescriptor {
        pub address: u8,
        pub number: u8,
        pub direction: EndpointDirection,
        pub transfer_type: EndpointTransferType,
        pub max_packet_size: u16,
        pub sync_type: EndpointSyncType,
        pub usage_type: EndpointUsageType,
        pub polling_interval: u8,
        pub refresh_rate: u8,
        /// audio
        pub synch_address: u8,
      }
      impl ::core::fmt::Debug for EndpointDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("EndpointDescriptor").field("address", &self.address).field("number", &self.number).field("direction", &self.direction).field("transfer-type", &self.transfer_type).field("max-packet-size", &self.max_packet_size).field("sync-type", &self.sync_type).field("usage-type", &self.usage_type).field("polling-interval", &self.polling_interval).field("refresh-rate", &self.refresh_rate).field("synch-address", &self.synch_address).finish()
        }
      }
      #[derive(Clone)]
      pub struct InterfaceDescriptor {
        pub interface_number: u8,
        pub setting_number: u8,
        pub class_code: u8,
        pub subclass_code: u8,
        pub protocol_code: u8,
        pub description: Option<u8>,
        pub num_endpoints: u8,
        pub endpoints: _rt::Vec::<EndpointDescriptor>,
      }
      impl ::core::fmt::Debug for InterfaceDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("InterfaceDescriptor").field("interface-number", &self.interface_number).field("setting-number", &self.setting_number).field("class-code", &self.class_code).field("subclass-code", &self.subclass_code).field("protocol-code", &self.protocol_code).field("description", &self.description).field("num-endpoints", &self.num_endpoints).field("endpoints", &self.endpoints).finish()
        }
      }
      #[derive(Clone)]
      pub struct DeviceInterface {
        pub number: u8,
        pub interface_descriptors: _rt::Vec::<InterfaceDescriptor>,
      }
      impl ::core::fmt::Debug for DeviceInterface {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("DeviceInterface").field("number", &self.number).field("interface-descriptors", &self.interface_descriptors).finish()
        }
      }
      #[derive(Clone)]
      pub struct ConfigDescriptor {
        pub number: u8,
        pub max_power: u16,
        pub self_powered: bool,
        pub remote_wakeup: bool,
        pub description: Option<u8>,
        pub num_interfaces: u8,
        pub interfaces: _rt::Vec::<DeviceInterface>,
      }
      impl ::core::fmt::Debug for ConfigDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ConfigDescriptor").field("number", &self.number).field("max-power", &self.max_power).field("self-powered", &self.self_powered).field("remote-wakeup", &self.remote_wakeup).field("description", &self.description).field("num-interfaces", &self.num_interfaces).field("interfaces", &self.interfaces).finish()
        }
      }
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct DeviceDescriptor {
        pub usb_version: Version,
        pub device_version: Version,
        pub manufacturer_string: Option<u8>,
        pub product_string: Option<u8>,
        pub serial_number_string: Option<u8>,
        pub class_code: u8,
        pub subclass_code: u8,
        pub protocol_code: u8,
        pub vendor_id: u16,
        pub product_id: u16,
        pub max_packet_size: u8,
        pub num_configurations: u8,
      }
      impl ::core::fmt::Debug for DeviceDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("DeviceDescriptor").field("usb-version", &self.usb_version).field("device-version", &self.device_version).field("manufacturer-string", &self.manufacturer_string).field("product-string", &self.product_string).field("serial-number-string", &self.serial_number_string).field("class-code", &self.class_code).field("subclass-code", &self.subclass_code).field("protocol-code", &self.protocol_code).field("vendor-id", &self.vendor_id).field("product-id", &self.product_id).field("max-packet-size", &self.max_packet_size).field("num-configurations", &self.num_configurations).finish()
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod usb {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type DeviceDescriptor = super::super::super::component::usb::descriptors::DeviceDescriptor;
      pub type ConfigDescriptor = super::super::super::component::usb::descriptors::ConfigDescriptor;
      pub type Speed = super::super::super::component::usb::types::Speed;
      pub type Duration = super::super::super::component::usb::types::Duration;
      pub type DeviceHandleError = super::super::super::component::usb::types::DeviceHandleError;
      pub type Language = super::super::super::component::usb::types::Language;

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct UsbDevice{
        handle: _rt::Resource<UsbDevice>,
      }

      impl UsbDevice{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for UsbDevice{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[resource-drop]usb-device"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }


      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Context{
        handle: _rt::Resource<Context>,
      }

      impl Context{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for Context{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[resource-drop]context"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }


      #[derive(Debug)]
      #[repr(transparent)]
      pub struct DeviceHandle{
        handle: _rt::Resource<DeviceHandle>,
      }

      impl DeviceHandle{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for DeviceHandle{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[resource-drop]device-handle"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      impl UsbDevice {
        #[allow(unused_unsafe, clippy::all)]
        pub fn device_descriptor(&self,) -> Result<DeviceDescriptor,()>{
          unsafe {
            #[repr(align(2))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]usb-device.device-descriptor"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(2).cast::<u8>());
                  let l3 = i32::from(*ptr0.add(3).cast::<u8>());
                  let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                  let l5 = i32::from(*ptr0.add(5).cast::<u8>());
                  let l6 = i32::from(*ptr0.add(6).cast::<u8>());
                  let l7 = i32::from(*ptr0.add(7).cast::<u8>());
                  let l8 = i32::from(*ptr0.add(8).cast::<u8>());
                  let l10 = i32::from(*ptr0.add(10).cast::<u8>());
                  let l12 = i32::from(*ptr0.add(12).cast::<u8>());
                  let l14 = i32::from(*ptr0.add(14).cast::<u8>());
                  let l15 = i32::from(*ptr0.add(15).cast::<u8>());
                  let l16 = i32::from(*ptr0.add(16).cast::<u8>());
                  let l17 = i32::from(*ptr0.add(18).cast::<u16>());
                  let l18 = i32::from(*ptr0.add(20).cast::<u16>());
                  let l19 = i32::from(*ptr0.add(22).cast::<u8>());
                  let l20 = i32::from(*ptr0.add(23).cast::<u8>());

                  super::super::super::component::usb::descriptors::DeviceDescriptor{
                    usb_version: super::super::super::component::usb::types::Version{
                      major: l2 as u8,
                      minor: l3 as u8,
                      subminor: l4 as u8,
                    },
                    device_version: super::super::super::component::usb::types::Version{
                      major: l5 as u8,
                      minor: l6 as u8,
                      subminor: l7 as u8,
                    },
                    manufacturer_string: match l8 {
                      0 => None,
                      1 => {
                        let e = {
                          let l9 = i32::from(*ptr0.add(9).cast::<u8>());

                          l9 as u8
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    product_string: match l10 {
                      0 => None,
                      1 => {
                        let e = {
                          let l11 = i32::from(*ptr0.add(11).cast::<u8>());

                          l11 as u8
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    serial_number_string: match l12 {
                      0 => None,
                      1 => {
                        let e = {
                          let l13 = i32::from(*ptr0.add(13).cast::<u8>());

                          l13 as u8
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    class_code: l14 as u8,
                    subclass_code: l15 as u8,
                    protocol_code: l16 as u8,
                    vendor_id: l17 as u16,
                    product_id: l18 as u16,
                    max_packet_size: l19 as u8,
                    num_configurations: l20 as u8,
                  }
                };
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl UsbDevice {
        #[allow(unused_unsafe, clippy::all)]
        pub fn config_descriptor(&self,) -> Result<ConfigDescriptor,()>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]usb-device.config-descriptor"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                  let l3 = i32::from(*ptr0.add(6).cast::<u16>());
                  let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                  let l5 = i32::from(*ptr0.add(9).cast::<u8>());
                  let l6 = i32::from(*ptr0.add(10).cast::<u8>());
                  let l8 = i32::from(*ptr0.add(12).cast::<u8>());
                  let l9 = *ptr0.add(16).cast::<*mut u8>();
                  let l10 = *ptr0.add(20).cast::<usize>();
                  let base36 = l9;
                  let len36 = l10;
                  let mut result36 = _rt::Vec::with_capacity(len36);
                  for i in 0..len36 {
                    let base = base36.add(i * 12);
                    let e36 = {
                      let l11 = i32::from(*base.add(0).cast::<u8>());
                      let l12 = *base.add(4).cast::<*mut u8>();
                      let l13 = *base.add(8).cast::<usize>();
                      let base35 = l12;
                      let len35 = l13;
                      let mut result35 = _rt::Vec::with_capacity(len35);
                      for i in 0..len35 {
                        let base = base35.add(i * 16);
                        let e35 = {
                          let l14 = i32::from(*base.add(0).cast::<u8>());
                          let l15 = i32::from(*base.add(1).cast::<u8>());
                          let l16 = i32::from(*base.add(2).cast::<u8>());
                          let l17 = i32::from(*base.add(3).cast::<u8>());
                          let l18 = i32::from(*base.add(4).cast::<u8>());
                          let l19 = i32::from(*base.add(5).cast::<u8>());
                          let l21 = i32::from(*base.add(7).cast::<u8>());
                          let l22 = *base.add(8).cast::<*mut u8>();
                          let l23 = *base.add(12).cast::<usize>();
                          let base34 = l22;
                          let len34 = l23;
                          let mut result34 = _rt::Vec::with_capacity(len34);
                          for i in 0..len34 {
                            let base = base34.add(i * 12);
                            let e34 = {
                              let l24 = i32::from(*base.add(0).cast::<u8>());
                              let l25 = i32::from(*base.add(1).cast::<u8>());
                              let l26 = i32::from(*base.add(2).cast::<u8>());
                              let l27 = i32::from(*base.add(3).cast::<u8>());
                              let l28 = i32::from(*base.add(4).cast::<u16>());
                              let l29 = i32::from(*base.add(6).cast::<u8>());
                              let l30 = i32::from(*base.add(7).cast::<u8>());
                              let l31 = i32::from(*base.add(8).cast::<u8>());
                              let l32 = i32::from(*base.add(9).cast::<u8>());
                              let l33 = i32::from(*base.add(10).cast::<u8>());

                              super::super::super::component::usb::descriptors::EndpointDescriptor{
                                address: l24 as u8,
                                number: l25 as u8,
                                direction: super::super::super::component::usb::types::EndpointDirection::_lift(l26 as u8),
                                transfer_type: super::super::super::component::usb::types::EndpointTransferType::_lift(l27 as u8),
                                max_packet_size: l28 as u16,
                                sync_type: super::super::super::component::usb::types::EndpointSyncType::_lift(l29 as u8),
                                usage_type: super::super::super::component::usb::types::EndpointUsageType::_lift(l30 as u8),
                                polling_interval: l31 as u8,
                                refresh_rate: l32 as u8,
                                synch_address: l33 as u8,
                              }
                            };
                            result34.push(e34);
                          }
                          _rt::cabi_dealloc(base34, len34 * 12, 2);

                          super::super::super::component::usb::descriptors::InterfaceDescriptor{
                            interface_number: l14 as u8,
                            setting_number: l15 as u8,
                            class_code: l16 as u8,
                            subclass_code: l17 as u8,
                            protocol_code: l18 as u8,
                            description: match l19 {
                              0 => None,
                              1 => {
                                let e = {
                                  let l20 = i32::from(*base.add(6).cast::<u8>());

                                  l20 as u8
                                };
                                Some(e)
                              }
                              _ => _rt::invalid_enum_discriminant(),
                            },
                            num_endpoints: l21 as u8,
                            endpoints: result34,
                          }
                        };
                        result35.push(e35);
                      }
                      _rt::cabi_dealloc(base35, len35 * 16, 4);

                      super::super::super::component::usb::descriptors::DeviceInterface{
                        number: l11 as u8,
                        interface_descriptors: result35,
                      }
                    };
                    result36.push(e36);
                  }
                  _rt::cabi_dealloc(base36, len36 * 12, 4);

                  super::super::super::component::usb::descriptors::ConfigDescriptor{
                    number: l2 as u8,
                    max_power: l3 as u16,
                    self_powered: _rt::bool_lift(l4 as u8),
                    remote_wakeup: _rt::bool_lift(l5 as u8),
                    description: match l6 {
                      0 => None,
                      1 => {
                        let e = {
                          let l7 = i32::from(*ptr0.add(11).cast::<u8>());

                          l7 as u8
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    num_interfaces: l8 as u8,
                    interfaces: result36,
                  }
                };
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl UsbDevice {
        #[allow(unused_unsafe, clippy::all)]
        pub fn bus_number(&self,) -> u8{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]usb-device.bus-number"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            ret as u8
          }
        }
      }
      impl UsbDevice {
        #[allow(unused_unsafe, clippy::all)]
        pub fn address(&self,) -> u8{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]usb-device.address"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            ret as u8
          }
        }
      }
      impl UsbDevice {
        #[allow(unused_unsafe, clippy::all)]
        pub fn speed(&self,) -> Speed{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]usb-device.speed"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            super::super::super::component::usb::types::Speed::_lift(ret as u8)
          }
        }
      }
      impl UsbDevice {
        #[allow(unused_unsafe, clippy::all)]
        pub fn open(&self,) -> Result<DeviceHandle,()>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]usb-device.open"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<i32>();

                  DeviceHandle::from_handle(l2 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl UsbDevice {
        #[allow(unused_unsafe, clippy::all)]
        pub fn port_number(&self,) -> u8{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]usb-device.port-number"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            ret as u8
          }
        }
      }
      impl Context {
        #[allow(unused_unsafe, clippy::all)]
        pub fn devices(&self,) -> Result<_rt::Vec::<UsbDevice>,()>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]context.devices"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<*mut u8>();
                  let l3 = *ptr0.add(8).cast::<usize>();
                  let base5 = l2;
                  let len5 = l3;
                  let mut result5 = _rt::Vec::with_capacity(len5);
                  for i in 0..len5 {
                    let base = base5.add(i * 4);
                    let e5 = {
                      let l4 = *base.add(0).cast::<i32>();

                      UsbDevice::from_handle(l4 as u32)
                    };
                    result5.push(e5);
                  }
                  _rt::cabi_dealloc(base5, len5 * 4, 4);

                  result5
                };
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Context {
        #[allow(unused_unsafe, clippy::all)]
        pub fn open_device_with_vid_pid(&self,vendor_id: u16,product_id: u16,) -> Option<DeviceHandle>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]context.open-device-with-vid-pid"]
              fn wit_import(_: i32, _: i32, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i32(&vendor_id), _rt::as_i32(&product_id), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => None,
              1 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<i32>();

                  DeviceHandle::from_handle(l2 as u32)
                };
                Some(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn device(&self,) -> UsbDevice{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.device"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            UsbDevice::from_handle(ret as u32)
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn active_configuration(&self,) -> Result<u8,()>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.active-configuration"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(1).cast::<u8>());

                  l2 as u8
                };
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn set_active_configuration(&self,config: u8,) -> Result<(),()>{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.set-active-configuration"]
              fn wit_import(_: i32, _: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32, _rt::as_i32(&config));
            match ret {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn unconfigure(&self,) -> Result<(),()>{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.unconfigure"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            match ret {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn reset(&self,) -> Result<(),()>{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.reset"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            match ret {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn clear_halt(&self,endpoint: u8,) -> Result<(),()>{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.clear-halt"]
              fn wit_import(_: i32, _: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32, _rt::as_i32(&endpoint));
            match ret {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn kernel_driver_active(&self,) -> Result<bool,()>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.kernel-driver-active"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(1).cast::<u8>());

                  _rt::bool_lift(l2 as u8)
                };
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn detach_kernel_driver(&self,) -> Result<(),()>{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.detach-kernel-driver"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            match ret {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn attach_kernel_driver(&self,) -> Result<(),()>{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.attach-kernel-driver"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            match ret {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn set_auto_attach_detach_kernel_driver(&self,auto: bool,) -> Result<(),()>{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.set-auto-attach-detach-kernel-driver"]
              fn wit_import(_: i32, _: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32, match &auto { true => 1, false => 0 });
            match ret {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn claim_interface(&self,iface: u8,) -> Result<(),()>{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.claim-interface"]
              fn wit_import(_: i32, _: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32, _rt::as_i32(&iface));
            match ret {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn release_interface(&self,iface: u8,) -> Result<(),()>{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.release-interface"]
              fn wit_import(_: i32, _: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32, _rt::as_i32(&iface));
            match ret {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn set_interface_alt_setting(&self,iface: u8,alt_setting: u8,) -> Result<(),()>{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.set-interface-alt-setting"]
              fn wit_import(_: i32, _: i32, _: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32, _rt::as_i32(&iface), _rt::as_i32(&alt_setting));
            match ret {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn read_interrupt(&self,endpoint: u8,timeout: Duration,) -> Result<(u64,_rt::Vec::<u8>,),DeviceHandleError>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.read-interrupt"]
              fn wit_import(_: i32, _: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i32(&endpoint), _rt::as_i64(timeout), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(8).cast::<i64>();
                  let l3 = *ptr0.add(16).cast::<*mut u8>();
                  let l4 = *ptr0.add(20).cast::<usize>();
                  let len5 = l4;

                  (l2 as u64, _rt::Vec::from_raw_parts(l3.cast(), len5, len5))
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l6 = i32::from(*ptr0.add(8).cast::<u8>());

                  super::super::super::component::usb::types::DeviceHandleError::_lift(l6 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn write_interrupt(&self,endpoint: u8,data: &[u8],timeout: Duration,) -> Result<u64,DeviceHandleError>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let vec0 = data;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.write-interrupt"]
              fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i32(&endpoint), ptr0.cast_mut(), len0, _rt::as_i64(timeout), ptr1);
            let l2 = i32::from(*ptr1.add(0).cast::<u8>());
            match l2 {
              0 => {
                let e = {
                  let l3 = *ptr1.add(8).cast::<i64>();

                  l3 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr1.add(8).cast::<u8>());

                  super::super::super::component::usb::types::DeviceHandleError::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn read_bulk(&self,endpoint: u8,max_size: u64,timeout: Duration,) -> Result<(u64,_rt::Vec::<u8>,),DeviceHandleError>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.read-bulk"]
              fn wit_import(_: i32, _: i32, _: i64, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i64, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i32(&endpoint), _rt::as_i64(&max_size), _rt::as_i64(timeout), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(8).cast::<i64>();
                  let l3 = *ptr0.add(16).cast::<*mut u8>();
                  let l4 = *ptr0.add(20).cast::<usize>();
                  let len5 = l4;

                  (l2 as u64, _rt::Vec::from_raw_parts(l3.cast(), len5, len5))
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l6 = i32::from(*ptr0.add(8).cast::<u8>());

                  super::super::super::component::usb::types::DeviceHandleError::_lift(l6 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn write_bulk(&self,endpoint: u8,data: &[u8],timeout: Duration,) -> Result<u64,DeviceHandleError>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let vec0 = data;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.write-bulk"]
              fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i32(&endpoint), ptr0.cast_mut(), len0, _rt::as_i64(timeout), ptr1);
            let l2 = i32::from(*ptr1.add(0).cast::<u8>());
            match l2 {
              0 => {
                let e = {
                  let l3 = *ptr1.add(8).cast::<i64>();

                  l3 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr1.add(8).cast::<u8>());

                  super::super::super::component::usb::types::DeviceHandleError::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn read_control(&self,request_type: u8,request: u8,value: u16,index: u16,max_size: u16,timeout: Duration,) -> Result<(u64,_rt::Vec::<u8>,),DeviceHandleError>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.read-control"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i32(&request_type), _rt::as_i32(&request), _rt::as_i32(&value), _rt::as_i32(&index), _rt::as_i32(&max_size), _rt::as_i64(timeout), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(8).cast::<i64>();
                  let l3 = *ptr0.add(16).cast::<*mut u8>();
                  let l4 = *ptr0.add(20).cast::<usize>();
                  let len5 = l4;

                  (l2 as u64, _rt::Vec::from_raw_parts(l3.cast(), len5, len5))
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l6 = i32::from(*ptr0.add(8).cast::<u8>());

                  super::super::super::component::usb::types::DeviceHandleError::_lift(l6 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn write_control(&self,request_type: u8,request: u8,value: u16,index: u16,data: &[u8],timeout: Duration,) -> Result<u64,DeviceHandleError>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let vec0 = data;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.write-control"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i32(&request_type), _rt::as_i32(&request), _rt::as_i32(&value), _rt::as_i32(&index), ptr0.cast_mut(), len0, _rt::as_i64(timeout), ptr1);
            let l2 = i32::from(*ptr1.add(0).cast::<u8>());
            match l2 {
              0 => {
                let e = {
                  let l3 = *ptr1.add(8).cast::<i64>();

                  l3 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr1.add(8).cast::<u8>());

                  super::super::super::component::usb::types::DeviceHandleError::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn read_languages(&self,timeout: Duration,) -> Result<_rt::Vec::<Language>,()>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.read-languages"]
              fn wit_import(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i64(timeout), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<*mut u8>();
                  let l3 = *ptr0.add(8).cast::<usize>();
                  let base11 = l2;
                  let len11 = l3;
                  let mut result11 = _rt::Vec::with_capacity(len11);
                  for i in 0..len11 {
                    let base = base11.add(i * 10);
                    let e11 = {
                      let l4 = i32::from(*base.add(0).cast::<u16>());
                      let l5 = i32::from(*base.add(2).cast::<u8>());
                      use super::super::super::component::usb::types::PrimaryLanguage as V7;
                      let v7 = match l5 {
                        0 => {
                          V7::Afrikaans
                        }
                        1 => {
                          V7::Albanian
                        }
                        2 => {
                          V7::Arabic
                        }
                        3 => {
                          V7::Armenian
                        }
                        4 => {
                          V7::Assamese
                        }
                        5 => {
                          V7::Azeri
                        }
                        6 => {
                          V7::Basque
                        }
                        7 => {
                          V7::Belarussian
                        }
                        8 => {
                          V7::Bengali
                        }
                        9 => {
                          V7::Bulgarian
                        }
                        10 => {
                          V7::Burmese
                        }
                        11 => {
                          V7::Catalan
                        }
                        12 => {
                          V7::Chinese
                        }
                        13 => {
                          V7::Croatian
                        }
                        14 => {
                          V7::Czech
                        }
                        15 => {
                          V7::Danish
                        }
                        16 => {
                          V7::Dutch
                        }
                        17 => {
                          V7::English
                        }
                        18 => {
                          V7::Estonian
                        }
                        19 => {
                          V7::Faeroese
                        }
                        20 => {
                          V7::Farsi
                        }
                        21 => {
                          V7::Finnish
                        }
                        22 => {
                          V7::French
                        }
                        23 => {
                          V7::Georgian
                        }
                        24 => {
                          V7::German
                        }
                        25 => {
                          V7::Greek
                        }
                        26 => {
                          V7::Gujarati
                        }
                        27 => {
                          V7::Hebrew
                        }
                        28 => {
                          V7::Hindi
                        }
                        29 => {
                          V7::Hungarian
                        }
                        30 => {
                          V7::Icelandic
                        }
                        31 => {
                          V7::Indonesian
                        }
                        32 => {
                          V7::Italian
                        }
                        33 => {
                          V7::Japanese
                        }
                        34 => {
                          V7::Kannada
                        }
                        35 => {
                          V7::Kashmiri
                        }
                        36 => {
                          V7::Kazakh
                        }
                        37 => {
                          V7::Konkani
                        }
                        38 => {
                          V7::Korean
                        }
                        39 => {
                          V7::Latvian
                        }
                        40 => {
                          V7::Lithuanian
                        }
                        41 => {
                          V7::Macedonian
                        }
                        42 => {
                          V7::Malay
                        }
                        43 => {
                          V7::Malayalam
                        }
                        44 => {
                          V7::Manipuri
                        }
                        45 => {
                          V7::Marathi
                        }
                        46 => {
                          V7::Nepali
                        }
                        47 => {
                          V7::Norwegian
                        }
                        48 => {
                          V7::Oriya
                        }
                        49 => {
                          V7::Polish
                        }
                        50 => {
                          V7::Portuguese
                        }
                        51 => {
                          V7::Punjabi
                        }
                        52 => {
                          V7::Romanian
                        }
                        53 => {
                          V7::Russian
                        }
                        54 => {
                          V7::Sanskrit
                        }
                        55 => {
                          V7::Serbian
                        }
                        56 => {
                          V7::Sindhi
                        }
                        57 => {
                          V7::Slovak
                        }
                        58 => {
                          V7::Slovenian
                        }
                        59 => {
                          V7::Spanish
                        }
                        60 => {
                          V7::Sutu
                        }
                        61 => {
                          V7::Swahili
                        }
                        62 => {
                          V7::Swedish
                        }
                        63 => {
                          V7::Tamil
                        }
                        64 => {
                          V7::Tatar
                        }
                        65 => {
                          V7::Telugu
                        }
                        66 => {
                          V7::Thai
                        }
                        67 => {
                          V7::Turkish
                        }
                        68 => {
                          V7::Ukrainian
                        }
                        69 => {
                          V7::Urdu
                        }
                        70 => {
                          V7::Uzbek
                        }
                        71 => {
                          V7::Vietnamese
                        }
                        72 => {
                          V7::Hid
                        }
                        n => {
                          debug_assert_eq!(n, 73, "invalid enum discriminant");
                          let e7 = {
                            let l6 = i32::from(*base.add(4).cast::<u16>());

                            l6 as u16
                          };
                          V7::Other(e7)
                        }
                      };
                      let l8 = i32::from(*base.add(6).cast::<u8>());
                      use super::super::super::component::usb::types::SubLanguage as V10;
                      let v10 = match l8 {
                        0 => {
                          V10::Standard
                        }
                        1 => {
                          V10::Classic
                        }
                        2 => {
                          V10::Traditional
                        }
                        3 => {
                          V10::Modern
                        }
                        4 => {
                          V10::Algeria
                        }
                        5 => {
                          V10::Argentina
                        }
                        6 => {
                          V10::Australia
                        }
                        7 => {
                          V10::Austria
                        }
                        8 => {
                          V10::Bahrain
                        }
                        9 => {
                          V10::Belgium
                        }
                        10 => {
                          V10::Belize
                        }
                        11 => {
                          V10::Bokmal
                        }
                        12 => {
                          V10::Bolivia
                        }
                        13 => {
                          V10::Brazil
                        }
                        14 => {
                          V10::BruneiDarussalam
                        }
                        15 => {
                          V10::Canada
                        }
                        16 => {
                          V10::Caribbean
                        }
                        17 => {
                          V10::Chile
                        }
                        18 => {
                          V10::China
                        }
                        19 => {
                          V10::Colombia
                        }
                        20 => {
                          V10::CostaRica
                        }
                        21 => {
                          V10::Cyrillic
                        }
                        22 => {
                          V10::DominicanRepublic
                        }
                        23 => {
                          V10::Ecuador
                        }
                        24 => {
                          V10::Egypt
                        }
                        25 => {
                          V10::ElSalvador
                        }
                        26 => {
                          V10::Finland
                        }
                        27 => {
                          V10::Guatemala
                        }
                        28 => {
                          V10::Honduras
                        }
                        29 => {
                          V10::HongKong
                        }
                        30 => {
                          V10::India
                        }
                        31 => {
                          V10::Iraq
                        }
                        32 => {
                          V10::Ireland
                        }
                        33 => {
                          V10::Jamaica
                        }
                        34 => {
                          V10::Johab
                        }
                        35 => {
                          V10::Jordan
                        }
                        36 => {
                          V10::Kuwait
                        }
                        37 => {
                          V10::Latin
                        }
                        38 => {
                          V10::Lebanon
                        }
                        39 => {
                          V10::Libya
                        }
                        40 => {
                          V10::Liechtenstein
                        }
                        41 => {
                          V10::Luxembourg
                        }
                        42 => {
                          V10::Macau
                        }
                        43 => {
                          V10::Malaysia
                        }
                        44 => {
                          V10::Mexico
                        }
                        45 => {
                          V10::Monaco
                        }
                        46 => {
                          V10::Morocco
                        }
                        47 => {
                          V10::Netherlands
                        }
                        48 => {
                          V10::NewZealand
                        }
                        49 => {
                          V10::Nicaragua
                        }
                        50 => {
                          V10::Nynorsk
                        }
                        51 => {
                          V10::Oman
                        }
                        52 => {
                          V10::Pakistan
                        }
                        53 => {
                          V10::Panama
                        }
                        54 => {
                          V10::Paraguay
                        }
                        55 => {
                          V10::Peru
                        }
                        56 => {
                          V10::Philippines
                        }
                        57 => {
                          V10::PuertoRico
                        }
                        58 => {
                          V10::Qatar
                        }
                        59 => {
                          V10::SaudiArabia
                        }
                        60 => {
                          V10::Singapore
                        }
                        61 => {
                          V10::SouthAfrica
                        }
                        62 => {
                          V10::Switzerland
                        }
                        63 => {
                          V10::Syria
                        }
                        64 => {
                          V10::Taiwan
                        }
                        65 => {
                          V10::Trinidad
                        }
                        66 => {
                          V10::Tunisia
                        }
                        67 => {
                          V10::UnitedArabEmirates
                        }
                        68 => {
                          V10::UnitedKingdom
                        }
                        69 => {
                          V10::UnitedStates
                        }
                        70 => {
                          V10::Uruguay
                        }
                        71 => {
                          V10::Venezuela
                        }
                        72 => {
                          V10::Yemen
                        }
                        73 => {
                          V10::Zimbabwe
                        }
                        74 => {
                          V10::UsageDataDescriptor
                        }
                        75 => {
                          V10::VendorDefined1
                        }
                        76 => {
                          V10::VendorDefined2
                        }
                        77 => {
                          V10::VendorDefined3
                        }
                        78 => {
                          V10::VendorDefined4
                        }
                        n => {
                          debug_assert_eq!(n, 79, "invalid enum discriminant");
                          let e10 = {
                            let l9 = i32::from(*base.add(8).cast::<u16>());

                            l9 as u16
                          };
                          V10::Other(e10)
                        }
                      };

                      super::super::super::component::usb::types::Language{
                        id: l4 as u16,
                        primary_language: v7,
                        sub_language: v10,
                      }
                    };
                    result11.push(e11);
                  }
                  _rt::cabi_dealloc(base11, len11 * 10, 2);

                  result11
                };
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn read_string_descriptor_ascii(&self,index: u8,) -> Result<_rt::String,()>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.read-string-descriptor-ascii"]
              fn wit_import(_: i32, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i32(&index), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<*mut u8>();
                  let l3 = *ptr0.add(8).cast::<usize>();
                  let len4 = l3;
                  let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);

                  _rt::string_lift(bytes4)
                };
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn read_string_descriptor(&self,language: Language,index: u8,timeout: Duration,) -> Result<_rt::String,()>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let super::super::super::component::usb::types::Language{ id:id0, primary_language:primary_language0, sub_language:sub_language0, } = language;
            use super::super::super::component::usb::types::PrimaryLanguage as V1;
            let (result2_0,result2_1,) = match primary_language0 {
              V1::Afrikaans=> {
                (0i32, 0i32)
              }
              V1::Albanian=> {
                (1i32, 0i32)
              }
              V1::Arabic=> {
                (2i32, 0i32)
              }
              V1::Armenian=> {
                (3i32, 0i32)
              }
              V1::Assamese=> {
                (4i32, 0i32)
              }
              V1::Azeri=> {
                (5i32, 0i32)
              }
              V1::Basque=> {
                (6i32, 0i32)
              }
              V1::Belarussian=> {
                (7i32, 0i32)
              }
              V1::Bengali=> {
                (8i32, 0i32)
              }
              V1::Bulgarian=> {
                (9i32, 0i32)
              }
              V1::Burmese=> {
                (10i32, 0i32)
              }
              V1::Catalan=> {
                (11i32, 0i32)
              }
              V1::Chinese=> {
                (12i32, 0i32)
              }
              V1::Croatian=> {
                (13i32, 0i32)
              }
              V1::Czech=> {
                (14i32, 0i32)
              }
              V1::Danish=> {
                (15i32, 0i32)
              }
              V1::Dutch=> {
                (16i32, 0i32)
              }
              V1::English=> {
                (17i32, 0i32)
              }
              V1::Estonian=> {
                (18i32, 0i32)
              }
              V1::Faeroese=> {
                (19i32, 0i32)
              }
              V1::Farsi=> {
                (20i32, 0i32)
              }
              V1::Finnish=> {
                (21i32, 0i32)
              }
              V1::French=> {
                (22i32, 0i32)
              }
              V1::Georgian=> {
                (23i32, 0i32)
              }
              V1::German=> {
                (24i32, 0i32)
              }
              V1::Greek=> {
                (25i32, 0i32)
              }
              V1::Gujarati=> {
                (26i32, 0i32)
              }
              V1::Hebrew=> {
                (27i32, 0i32)
              }
              V1::Hindi=> {
                (28i32, 0i32)
              }
              V1::Hungarian=> {
                (29i32, 0i32)
              }
              V1::Icelandic=> {
                (30i32, 0i32)
              }
              V1::Indonesian=> {
                (31i32, 0i32)
              }
              V1::Italian=> {
                (32i32, 0i32)
              }
              V1::Japanese=> {
                (33i32, 0i32)
              }
              V1::Kannada=> {
                (34i32, 0i32)
              }
              V1::Kashmiri=> {
                (35i32, 0i32)
              }
              V1::Kazakh=> {
                (36i32, 0i32)
              }
              V1::Konkani=> {
                (37i32, 0i32)
              }
              V1::Korean=> {
                (38i32, 0i32)
              }
              V1::Latvian=> {
                (39i32, 0i32)
              }
              V1::Lithuanian=> {
                (40i32, 0i32)
              }
              V1::Macedonian=> {
                (41i32, 0i32)
              }
              V1::Malay=> {
                (42i32, 0i32)
              }
              V1::Malayalam=> {
                (43i32, 0i32)
              }
              V1::Manipuri=> {
                (44i32, 0i32)
              }
              V1::Marathi=> {
                (45i32, 0i32)
              }
              V1::Nepali=> {
                (46i32, 0i32)
              }
              V1::Norwegian=> {
                (47i32, 0i32)
              }
              V1::Oriya=> {
                (48i32, 0i32)
              }
              V1::Polish=> {
                (49i32, 0i32)
              }
              V1::Portuguese=> {
                (50i32, 0i32)
              }
              V1::Punjabi=> {
                (51i32, 0i32)
              }
              V1::Romanian=> {
                (52i32, 0i32)
              }
              V1::Russian=> {
                (53i32, 0i32)
              }
              V1::Sanskrit=> {
                (54i32, 0i32)
              }
              V1::Serbian=> {
                (55i32, 0i32)
              }
              V1::Sindhi=> {
                (56i32, 0i32)
              }
              V1::Slovak=> {
                (57i32, 0i32)
              }
              V1::Slovenian=> {
                (58i32, 0i32)
              }
              V1::Spanish=> {
                (59i32, 0i32)
              }
              V1::Sutu=> {
                (60i32, 0i32)
              }
              V1::Swahili=> {
                (61i32, 0i32)
              }
              V1::Swedish=> {
                (62i32, 0i32)
              }
              V1::Tamil=> {
                (63i32, 0i32)
              }
              V1::Tatar=> {
                (64i32, 0i32)
              }
              V1::Telugu=> {
                (65i32, 0i32)
              }
              V1::Thai=> {
                (66i32, 0i32)
              }
              V1::Turkish=> {
                (67i32, 0i32)
              }
              V1::Ukrainian=> {
                (68i32, 0i32)
              }
              V1::Urdu=> {
                (69i32, 0i32)
              }
              V1::Uzbek=> {
                (70i32, 0i32)
              }
              V1::Vietnamese=> {
                (71i32, 0i32)
              }
              V1::Hid=> {
                (72i32, 0i32)
              }
              V1::Other(e) => (73i32, _rt::as_i32(e)),
            };
            use super::super::super::component::usb::types::SubLanguage as V3;
            let (result4_0,result4_1,) = match sub_language0 {
              V3::Standard=> {
                (0i32, 0i32)
              }
              V3::Classic=> {
                (1i32, 0i32)
              }
              V3::Traditional=> {
                (2i32, 0i32)
              }
              V3::Modern=> {
                (3i32, 0i32)
              }
              V3::Algeria=> {
                (4i32, 0i32)
              }
              V3::Argentina=> {
                (5i32, 0i32)
              }
              V3::Australia=> {
                (6i32, 0i32)
              }
              V3::Austria=> {
                (7i32, 0i32)
              }
              V3::Bahrain=> {
                (8i32, 0i32)
              }
              V3::Belgium=> {
                (9i32, 0i32)
              }
              V3::Belize=> {
                (10i32, 0i32)
              }
              V3::Bokmal=> {
                (11i32, 0i32)
              }
              V3::Bolivia=> {
                (12i32, 0i32)
              }
              V3::Brazil=> {
                (13i32, 0i32)
              }
              V3::BruneiDarussalam=> {
                (14i32, 0i32)
              }
              V3::Canada=> {
                (15i32, 0i32)
              }
              V3::Caribbean=> {
                (16i32, 0i32)
              }
              V3::Chile=> {
                (17i32, 0i32)
              }
              V3::China=> {
                (18i32, 0i32)
              }
              V3::Colombia=> {
                (19i32, 0i32)
              }
              V3::CostaRica=> {
                (20i32, 0i32)
              }
              V3::Cyrillic=> {
                (21i32, 0i32)
              }
              V3::DominicanRepublic=> {
                (22i32, 0i32)
              }
              V3::Ecuador=> {
                (23i32, 0i32)
              }
              V3::Egypt=> {
                (24i32, 0i32)
              }
              V3::ElSalvador=> {
                (25i32, 0i32)
              }
              V3::Finland=> {
                (26i32, 0i32)
              }
              V3::Guatemala=> {
                (27i32, 0i32)
              }
              V3::Honduras=> {
                (28i32, 0i32)
              }
              V3::HongKong=> {
                (29i32, 0i32)
              }
              V3::India=> {
                (30i32, 0i32)
              }
              V3::Iraq=> {
                (31i32, 0i32)
              }
              V3::Ireland=> {
                (32i32, 0i32)
              }
              V3::Jamaica=> {
                (33i32, 0i32)
              }
              V3::Johab=> {
                (34i32, 0i32)
              }
              V3::Jordan=> {
                (35i32, 0i32)
              }
              V3::Kuwait=> {
                (36i32, 0i32)
              }
              V3::Latin=> {
                (37i32, 0i32)
              }
              V3::Lebanon=> {
                (38i32, 0i32)
              }
              V3::Libya=> {
                (39i32, 0i32)
              }
              V3::Liechtenstein=> {
                (40i32, 0i32)
              }
              V3::Luxembourg=> {
                (41i32, 0i32)
              }
              V3::Macau=> {
                (42i32, 0i32)
              }
              V3::Malaysia=> {
                (43i32, 0i32)
              }
              V3::Mexico=> {
                (44i32, 0i32)
              }
              V3::Monaco=> {
                (45i32, 0i32)
              }
              V3::Morocco=> {
                (46i32, 0i32)
              }
              V3::Netherlands=> {
                (47i32, 0i32)
              }
              V3::NewZealand=> {
                (48i32, 0i32)
              }
              V3::Nicaragua=> {
                (49i32, 0i32)
              }
              V3::Nynorsk=> {
                (50i32, 0i32)
              }
              V3::Oman=> {
                (51i32, 0i32)
              }
              V3::Pakistan=> {
                (52i32, 0i32)
              }
              V3::Panama=> {
                (53i32, 0i32)
              }
              V3::Paraguay=> {
                (54i32, 0i32)
              }
              V3::Peru=> {
                (55i32, 0i32)
              }
              V3::Philippines=> {
                (56i32, 0i32)
              }
              V3::PuertoRico=> {
                (57i32, 0i32)
              }
              V3::Qatar=> {
                (58i32, 0i32)
              }
              V3::SaudiArabia=> {
                (59i32, 0i32)
              }
              V3::Singapore=> {
                (60i32, 0i32)
              }
              V3::SouthAfrica=> {
                (61i32, 0i32)
              }
              V3::Switzerland=> {
                (62i32, 0i32)
              }
              V3::Syria=> {
                (63i32, 0i32)
              }
              V3::Taiwan=> {
                (64i32, 0i32)
              }
              V3::Trinidad=> {
                (65i32, 0i32)
              }
              V3::Tunisia=> {
                (66i32, 0i32)
              }
              V3::UnitedArabEmirates=> {
                (67i32, 0i32)
              }
              V3::UnitedKingdom=> {
                (68i32, 0i32)
              }
              V3::UnitedStates=> {
                (69i32, 0i32)
              }
              V3::Uruguay=> {
                (70i32, 0i32)
              }
              V3::Venezuela=> {
                (71i32, 0i32)
              }
              V3::Yemen=> {
                (72i32, 0i32)
              }
              V3::Zimbabwe=> {
                (73i32, 0i32)
              }
              V3::UsageDataDescriptor=> {
                (74i32, 0i32)
              }
              V3::VendorDefined1=> {
                (75i32, 0i32)
              }
              V3::VendorDefined2=> {
                (76i32, 0i32)
              }
              V3::VendorDefined3=> {
                (77i32, 0i32)
              }
              V3::VendorDefined4=> {
                (78i32, 0i32)
              }
              V3::Other(e) => (79i32, _rt::as_i32(e)),
            };
            let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.read-string-descriptor"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i32(id0), result2_0, result2_1, result4_0, result4_1, _rt::as_i32(&index), _rt::as_i64(timeout), ptr5);
            let l6 = i32::from(*ptr5.add(0).cast::<u8>());
            match l6 {
              0 => {
                let e = {
                  let l7 = *ptr5.add(4).cast::<*mut u8>();
                  let l8 = *ptr5.add(8).cast::<usize>();
                  let len9 = l8;
                  let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);

                  _rt::string_lift(bytes9)
                };
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn read_manufacturer_string_ascii(&self,device: DeviceDescriptor,){
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();*ptr0.add(0).cast::<i32>() = (self).handle() as i32;
            let super::super::super::component::usb::descriptors::DeviceDescriptor{ usb_version:usb_version1, device_version:device_version1, manufacturer_string:manufacturer_string1, product_string:product_string1, serial_number_string:serial_number_string1, class_code:class_code1, subclass_code:subclass_code1, protocol_code:protocol_code1, vendor_id:vendor_id1, product_id:product_id1, max_packet_size:max_packet_size1, num_configurations:num_configurations1, } = device;
            let super::super::super::component::usb::types::Version{ major:major2, minor:minor2, subminor:subminor2, } = usb_version1;
            *ptr0.add(4).cast::<u8>() = (_rt::as_i32(major2)) as u8;
            *ptr0.add(5).cast::<u8>() = (_rt::as_i32(minor2)) as u8;
            *ptr0.add(6).cast::<u8>() = (_rt::as_i32(subminor2)) as u8;
            let super::super::super::component::usb::types::Version{ major:major3, minor:minor3, subminor:subminor3, } = device_version1;
            *ptr0.add(7).cast::<u8>() = (_rt::as_i32(major3)) as u8;
            *ptr0.add(8).cast::<u8>() = (_rt::as_i32(minor3)) as u8;
            *ptr0.add(9).cast::<u8>() = (_rt::as_i32(subminor3)) as u8;
            match manufacturer_string1 {
              Some(e) => {
                *ptr0.add(10).cast::<u8>() = (1i32) as u8;
                *ptr0.add(11).cast::<u8>() = (_rt::as_i32(e)) as u8;
              },
              None => {
                {
                  *ptr0.add(10).cast::<u8>() = (0i32) as u8;
                }
              },
            };match product_string1 {
              Some(e) => {
                *ptr0.add(12).cast::<u8>() = (1i32) as u8;
                *ptr0.add(13).cast::<u8>() = (_rt::as_i32(e)) as u8;
              },
              None => {
                {
                  *ptr0.add(12).cast::<u8>() = (0i32) as u8;
                }
              },
            };match serial_number_string1 {
              Some(e) => {
                *ptr0.add(14).cast::<u8>() = (1i32) as u8;
                *ptr0.add(15).cast::<u8>() = (_rt::as_i32(e)) as u8;
              },
              None => {
                {
                  *ptr0.add(14).cast::<u8>() = (0i32) as u8;
                }
              },
            };*ptr0.add(16).cast::<u8>() = (_rt::as_i32(class_code1)) as u8;
            *ptr0.add(17).cast::<u8>() = (_rt::as_i32(subclass_code1)) as u8;
            *ptr0.add(18).cast::<u8>() = (_rt::as_i32(protocol_code1)) as u8;
            *ptr0.add(20).cast::<u16>() = (_rt::as_i32(vendor_id1)) as u16;
            *ptr0.add(22).cast::<u16>() = (_rt::as_i32(product_id1)) as u16;
            *ptr0.add(24).cast::<u8>() = (_rt::as_i32(max_packet_size1)) as u8;
            *ptr0.add(25).cast::<u8>() = (_rt::as_i32(num_configurations1)) as u8;

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.1")]
            extern "C" {
              #[link_name = "[method]device-handle.read-manufacturer-string-ascii"]
              fn wit_import(_: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: *mut u8, ){ unreachable!() }
            wit_import(ptr0);
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      pub fn get_context() -> Result<Context,()>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "component:usb/usb@0.2.1")]
          extern "C" {
            #[link_name = "get-context"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => {
              let e = {
                let l2 = *ptr0.add(4).cast::<i32>();

                Context::from_handle(l2 as u32)
              };
              Ok(e)
            }
            1 => {
              let e = ();
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod events {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      pub type UsbDevice = super::super::super::component::usb::usb::UsbDevice;
      pub enum DeviceConnectionEvent {
        Pending,
        Connected(UsbDevice),
        Disconnected(UsbDevice),
      }
      impl ::core::fmt::Debug for DeviceConnectionEvent {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            DeviceConnectionEvent::Pending => {
              f.debug_tuple("DeviceConnectionEvent::Pending").finish()
            }
            DeviceConnectionEvent::Connected(e) => {
              f.debug_tuple("DeviceConnectionEvent::Connected").field(e).finish()
            }
            DeviceConnectionEvent::Disconnected(e) => {
              f.debug_tuple("DeviceConnectionEvent::Disconnected").field(e).finish()
            }
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// TODO: wasip3 will support async functions and streams
      pub fn update() -> DeviceConnectionEvent{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "component:usb/events@0.2.1")]
          extern "C" {
            #[link_name = "update"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          let v4 = match l1 {
            0 => {
              DeviceConnectionEvent::Pending
            }
            1 => {
              let e4 = {
                let l2 = *ptr0.add(4).cast::<i32>();

                super::super::super::component::usb::usb::UsbDevice::from_handle(l2 as u32)
              };
              DeviceConnectionEvent::Connected(e4)
            }
            n => {
              debug_assert_eq!(n, 2, "invalid enum discriminant");
              let e4 = {
                let l3 = *ptr0.add(4).cast::<i32>();

                super::super::super::component::usb::usb::UsbDevice::from_handle(l3 as u32)
              };
              DeviceConnectionEvent::Disconnected(e4)
            }
          };
          v4
        }
      }

    }

  }
}
#[allow(dead_code)]
pub mod exports {
  #[allow(dead_code)]
  pub mod component {
    #[allow(dead_code)]
    pub mod usb {
      #[allow(dead_code, clippy::all)]
      pub mod types {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
        #[repr(u8)]
        #[derive(Clone, Copy, Eq, PartialEq)]
        pub enum EndpointDirection {
          In,
          Out,
        }
        impl ::core::fmt::Debug for EndpointDirection {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              EndpointDirection::In => {
                f.debug_tuple("EndpointDirection::In").finish()
              }
              EndpointDirection::Out => {
                f.debug_tuple("EndpointDirection::Out").finish()
              }
            }
          }
        }

        impl EndpointDirection{
          pub(crate) unsafe fn _lift(val: u8) -> EndpointDirection{
            if !cfg!(debug_assertions) {
              return ::core::mem::transmute(val);
            }

            match val {
              0 => EndpointDirection::In,
              1 => EndpointDirection::Out,

              _ => panic!("invalid enum discriminant"),
            }
          }
        }

        #[repr(u8)]
        #[derive(Clone, Copy, Eq, PartialEq)]
        pub enum EndpointTransferType {
          Control,
          Isochronous,
          Bulk,
          Interrupt,
        }
        impl ::core::fmt::Debug for EndpointTransferType {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              EndpointTransferType::Control => {
                f.debug_tuple("EndpointTransferType::Control").finish()
              }
              EndpointTransferType::Isochronous => {
                f.debug_tuple("EndpointTransferType::Isochronous").finish()
              }
              EndpointTransferType::Bulk => {
                f.debug_tuple("EndpointTransferType::Bulk").finish()
              }
              EndpointTransferType::Interrupt => {
                f.debug_tuple("EndpointTransferType::Interrupt").finish()
              }
            }
          }
        }

        impl EndpointTransferType{
          pub(crate) unsafe fn _lift(val: u8) -> EndpointTransferType{
            if !cfg!(debug_assertions) {
              return ::core::mem::transmute(val);
            }

            match val {
              0 => EndpointTransferType::Control,
              1 => EndpointTransferType::Isochronous,
              2 => EndpointTransferType::Bulk,
              3 => EndpointTransferType::Interrupt,

              _ => panic!("invalid enum discriminant"),
            }
          }
        }

        #[repr(u8)]
        #[derive(Clone, Copy, Eq, PartialEq)]
        pub enum EndpointSyncType {
          NoSync,
          Async,
          Adaptive,
          Synchronous,
        }
        impl ::core::fmt::Debug for EndpointSyncType {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              EndpointSyncType::NoSync => {
                f.debug_tuple("EndpointSyncType::NoSync").finish()
              }
              EndpointSyncType::Async => {
                f.debug_tuple("EndpointSyncType::Async").finish()
              }
              EndpointSyncType::Adaptive => {
                f.debug_tuple("EndpointSyncType::Adaptive").finish()
              }
              EndpointSyncType::Synchronous => {
                f.debug_tuple("EndpointSyncType::Synchronous").finish()
              }
            }
          }
        }

        impl EndpointSyncType{
          pub(crate) unsafe fn _lift(val: u8) -> EndpointSyncType{
            if !cfg!(debug_assertions) {
              return ::core::mem::transmute(val);
            }

            match val {
              0 => EndpointSyncType::NoSync,
              1 => EndpointSyncType::Async,
              2 => EndpointSyncType::Adaptive,
              3 => EndpointSyncType::Synchronous,

              _ => panic!("invalid enum discriminant"),
            }
          }
        }

        #[repr(u8)]
        #[derive(Clone, Copy, Eq, PartialEq)]
        pub enum EndpointUsageType {
          Data,
          Feedback,
          FeedbackData,
          Reserved,
        }
        impl ::core::fmt::Debug for EndpointUsageType {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              EndpointUsageType::Data => {
                f.debug_tuple("EndpointUsageType::Data").finish()
              }
              EndpointUsageType::Feedback => {
                f.debug_tuple("EndpointUsageType::Feedback").finish()
              }
              EndpointUsageType::FeedbackData => {
                f.debug_tuple("EndpointUsageType::FeedbackData").finish()
              }
              EndpointUsageType::Reserved => {
                f.debug_tuple("EndpointUsageType::Reserved").finish()
              }
            }
          }
        }

        impl EndpointUsageType{
          pub(crate) unsafe fn _lift(val: u8) -> EndpointUsageType{
            if !cfg!(debug_assertions) {
              return ::core::mem::transmute(val);
            }

            match val {
              0 => EndpointUsageType::Data,
              1 => EndpointUsageType::Feedback,
              2 => EndpointUsageType::FeedbackData,
              3 => EndpointUsageType::Reserved,

              _ => panic!("invalid enum discriminant"),
            }
          }
        }

        #[repr(C)]
        #[derive(Clone, Copy)]
        pub struct Version {
          pub major: u8,
          pub minor: u8,
          pub subminor: u8,
        }
        impl ::core::fmt::Debug for Version {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Version").field("major", &self.major).field("minor", &self.minor).field("subminor", &self.subminor).finish()
          }
        }
        #[repr(u8)]
        #[derive(Clone, Copy, Eq, PartialEq)]
        pub enum Speed {
          Unknown,
          Low,
          Full,
          High,
          Super,
          Superplus,
        }
        impl ::core::fmt::Debug for Speed {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              Speed::Unknown => {
                f.debug_tuple("Speed::Unknown").finish()
              }
              Speed::Low => {
                f.debug_tuple("Speed::Low").finish()
              }
              Speed::Full => {
                f.debug_tuple("Speed::Full").finish()
              }
              Speed::High => {
                f.debug_tuple("Speed::High").finish()
              }
              Speed::Super => {
                f.debug_tuple("Speed::Super").finish()
              }
              Speed::Superplus => {
                f.debug_tuple("Speed::Superplus").finish()
              }
            }
          }
        }

        impl Speed{
          pub(crate) unsafe fn _lift(val: u8) -> Speed{
            if !cfg!(debug_assertions) {
              return ::core::mem::transmute(val);
            }

            match val {
              0 => Speed::Unknown,
              1 => Speed::Low,
              2 => Speed::Full,
              3 => Speed::High,
              4 => Speed::Super,
              5 => Speed::Superplus,

              _ => panic!("invalid enum discriminant"),
            }
          }
        }

        #[repr(u8)]
        #[derive(Clone, Copy, Eq, PartialEq)]
        pub enum DeviceHandleError {
          InvalidParam,
          Timeout,
          Pipe,
          Overflow,
          NoDevice,
          Io,
        }
        impl DeviceHandleError{
          pub fn name(&self) -> &'static str {
            match self {
              DeviceHandleError::InvalidParam => "invalid-param",
              DeviceHandleError::Timeout => "timeout",
              DeviceHandleError::Pipe => "pipe",
              DeviceHandleError::Overflow => "overflow",
              DeviceHandleError::NoDevice => "no-device",
              DeviceHandleError::Io => "io",
            }
          }
          pub fn message(&self) -> &'static str {
            match self {
              DeviceHandleError::InvalidParam => "",
              DeviceHandleError::Timeout => "",
              DeviceHandleError::Pipe => "",
              DeviceHandleError::Overflow => "",
              DeviceHandleError::NoDevice => "",
              DeviceHandleError::Io => "",
            }
          }
        }
        impl ::core::fmt::Debug for DeviceHandleError{
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("DeviceHandleError")
            .field("code", &(*self as i32))
            .field("name", &self.name())
            .field("message", &self.message())
            .finish()
          }
        }
        impl ::core::fmt::Display for DeviceHandleError{
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(f, "{} (error {})", self.name(), *self as i32)
          }
        }

        impl std::error::Error for DeviceHandleError {}

        impl DeviceHandleError{
          pub(crate) unsafe fn _lift(val: u8) -> DeviceHandleError{
            if !cfg!(debug_assertions) {
              return ::core::mem::transmute(val);
            }

            match val {
              0 => DeviceHandleError::InvalidParam,
              1 => DeviceHandleError::Timeout,
              2 => DeviceHandleError::Pipe,
              3 => DeviceHandleError::Overflow,
              4 => DeviceHandleError::NoDevice,
              5 => DeviceHandleError::Io,

              _ => panic!("invalid enum discriminant"),
            }
          }
        }

        pub type Duration = u64;
        #[derive(Clone, Copy)]
        pub enum PrimaryLanguage {
          Afrikaans,
          Albanian,
          Arabic,
          Armenian,
          Assamese,
          Azeri,
          Basque,
          Belarussian,
          Bengali,
          Bulgarian,
          Burmese,
          Catalan,
          Chinese,
          Croatian,
          Czech,
          Danish,
          Dutch,
          English,
          Estonian,
          Faeroese,
          Farsi,
          Finnish,
          French,
          Georgian,
          German,
          Greek,
          Gujarati,
          Hebrew,
          Hindi,
          Hungarian,
          Icelandic,
          Indonesian,
          Italian,
          Japanese,
          Kannada,
          Kashmiri,
          Kazakh,
          Konkani,
          Korean,
          Latvian,
          Lithuanian,
          Macedonian,
          Malay,
          Malayalam,
          Manipuri,
          Marathi,
          Nepali,
          Norwegian,
          Oriya,
          Polish,
          Portuguese,
          Punjabi,
          Romanian,
          Russian,
          Sanskrit,
          Serbian,
          Sindhi,
          Slovak,
          Slovenian,
          Spanish,
          Sutu,
          Swahili,
          Swedish,
          Tamil,
          Tatar,
          Telugu,
          Thai,
          Turkish,
          Ukrainian,
          Urdu,
          Uzbek,
          Vietnamese,
          Hid,
          Other(u16),
        }
        impl ::core::fmt::Debug for PrimaryLanguage {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              PrimaryLanguage::Afrikaans => {
                f.debug_tuple("PrimaryLanguage::Afrikaans").finish()
              }
              PrimaryLanguage::Albanian => {
                f.debug_tuple("PrimaryLanguage::Albanian").finish()
              }
              PrimaryLanguage::Arabic => {
                f.debug_tuple("PrimaryLanguage::Arabic").finish()
              }
              PrimaryLanguage::Armenian => {
                f.debug_tuple("PrimaryLanguage::Armenian").finish()
              }
              PrimaryLanguage::Assamese => {
                f.debug_tuple("PrimaryLanguage::Assamese").finish()
              }
              PrimaryLanguage::Azeri => {
                f.debug_tuple("PrimaryLanguage::Azeri").finish()
              }
              PrimaryLanguage::Basque => {
                f.debug_tuple("PrimaryLanguage::Basque").finish()
              }
              PrimaryLanguage::Belarussian => {
                f.debug_tuple("PrimaryLanguage::Belarussian").finish()
              }
              PrimaryLanguage::Bengali => {
                f.debug_tuple("PrimaryLanguage::Bengali").finish()
              }
              PrimaryLanguage::Bulgarian => {
                f.debug_tuple("PrimaryLanguage::Bulgarian").finish()
              }
              PrimaryLanguage::Burmese => {
                f.debug_tuple("PrimaryLanguage::Burmese").finish()
              }
              PrimaryLanguage::Catalan => {
                f.debug_tuple("PrimaryLanguage::Catalan").finish()
              }
              PrimaryLanguage::Chinese => {
                f.debug_tuple("PrimaryLanguage::Chinese").finish()
              }
              PrimaryLanguage::Croatian => {
                f.debug_tuple("PrimaryLanguage::Croatian").finish()
              }
              PrimaryLanguage::Czech => {
                f.debug_tuple("PrimaryLanguage::Czech").finish()
              }
              PrimaryLanguage::Danish => {
                f.debug_tuple("PrimaryLanguage::Danish").finish()
              }
              PrimaryLanguage::Dutch => {
                f.debug_tuple("PrimaryLanguage::Dutch").finish()
              }
              PrimaryLanguage::English => {
                f.debug_tuple("PrimaryLanguage::English").finish()
              }
              PrimaryLanguage::Estonian => {
                f.debug_tuple("PrimaryLanguage::Estonian").finish()
              }
              PrimaryLanguage::Faeroese => {
                f.debug_tuple("PrimaryLanguage::Faeroese").finish()
              }
              PrimaryLanguage::Farsi => {
                f.debug_tuple("PrimaryLanguage::Farsi").finish()
              }
              PrimaryLanguage::Finnish => {
                f.debug_tuple("PrimaryLanguage::Finnish").finish()
              }
              PrimaryLanguage::French => {
                f.debug_tuple("PrimaryLanguage::French").finish()
              }
              PrimaryLanguage::Georgian => {
                f.debug_tuple("PrimaryLanguage::Georgian").finish()
              }
              PrimaryLanguage::German => {
                f.debug_tuple("PrimaryLanguage::German").finish()
              }
              PrimaryLanguage::Greek => {
                f.debug_tuple("PrimaryLanguage::Greek").finish()
              }
              PrimaryLanguage::Gujarati => {
                f.debug_tuple("PrimaryLanguage::Gujarati").finish()
              }
              PrimaryLanguage::Hebrew => {
                f.debug_tuple("PrimaryLanguage::Hebrew").finish()
              }
              PrimaryLanguage::Hindi => {
                f.debug_tuple("PrimaryLanguage::Hindi").finish()
              }
              PrimaryLanguage::Hungarian => {
                f.debug_tuple("PrimaryLanguage::Hungarian").finish()
              }
              PrimaryLanguage::Icelandic => {
                f.debug_tuple("PrimaryLanguage::Icelandic").finish()
              }
              PrimaryLanguage::Indonesian => {
                f.debug_tuple("PrimaryLanguage::Indonesian").finish()
              }
              PrimaryLanguage::Italian => {
                f.debug_tuple("PrimaryLanguage::Italian").finish()
              }
              PrimaryLanguage::Japanese => {
                f.debug_tuple("PrimaryLanguage::Japanese").finish()
              }
              PrimaryLanguage::Kannada => {
                f.debug_tuple("PrimaryLanguage::Kannada").finish()
              }
              PrimaryLanguage::Kashmiri => {
                f.debug_tuple("PrimaryLanguage::Kashmiri").finish()
              }
              PrimaryLanguage::Kazakh => {
                f.debug_tuple("PrimaryLanguage::Kazakh").finish()
              }
              PrimaryLanguage::Konkani => {
                f.debug_tuple("PrimaryLanguage::Konkani").finish()
              }
              PrimaryLanguage::Korean => {
                f.debug_tuple("PrimaryLanguage::Korean").finish()
              }
              PrimaryLanguage::Latvian => {
                f.debug_tuple("PrimaryLanguage::Latvian").finish()
              }
              PrimaryLanguage::Lithuanian => {
                f.debug_tuple("PrimaryLanguage::Lithuanian").finish()
              }
              PrimaryLanguage::Macedonian => {
                f.debug_tuple("PrimaryLanguage::Macedonian").finish()
              }
              PrimaryLanguage::Malay => {
                f.debug_tuple("PrimaryLanguage::Malay").finish()
              }
              PrimaryLanguage::Malayalam => {
                f.debug_tuple("PrimaryLanguage::Malayalam").finish()
              }
              PrimaryLanguage::Manipuri => {
                f.debug_tuple("PrimaryLanguage::Manipuri").finish()
              }
              PrimaryLanguage::Marathi => {
                f.debug_tuple("PrimaryLanguage::Marathi").finish()
              }
              PrimaryLanguage::Nepali => {
                f.debug_tuple("PrimaryLanguage::Nepali").finish()
              }
              PrimaryLanguage::Norwegian => {
                f.debug_tuple("PrimaryLanguage::Norwegian").finish()
              }
              PrimaryLanguage::Oriya => {
                f.debug_tuple("PrimaryLanguage::Oriya").finish()
              }
              PrimaryLanguage::Polish => {
                f.debug_tuple("PrimaryLanguage::Polish").finish()
              }
              PrimaryLanguage::Portuguese => {
                f.debug_tuple("PrimaryLanguage::Portuguese").finish()
              }
              PrimaryLanguage::Punjabi => {
                f.debug_tuple("PrimaryLanguage::Punjabi").finish()
              }
              PrimaryLanguage::Romanian => {
                f.debug_tuple("PrimaryLanguage::Romanian").finish()
              }
              PrimaryLanguage::Russian => {
                f.debug_tuple("PrimaryLanguage::Russian").finish()
              }
              PrimaryLanguage::Sanskrit => {
                f.debug_tuple("PrimaryLanguage::Sanskrit").finish()
              }
              PrimaryLanguage::Serbian => {
                f.debug_tuple("PrimaryLanguage::Serbian").finish()
              }
              PrimaryLanguage::Sindhi => {
                f.debug_tuple("PrimaryLanguage::Sindhi").finish()
              }
              PrimaryLanguage::Slovak => {
                f.debug_tuple("PrimaryLanguage::Slovak").finish()
              }
              PrimaryLanguage::Slovenian => {
                f.debug_tuple("PrimaryLanguage::Slovenian").finish()
              }
              PrimaryLanguage::Spanish => {
                f.debug_tuple("PrimaryLanguage::Spanish").finish()
              }
              PrimaryLanguage::Sutu => {
                f.debug_tuple("PrimaryLanguage::Sutu").finish()
              }
              PrimaryLanguage::Swahili => {
                f.debug_tuple("PrimaryLanguage::Swahili").finish()
              }
              PrimaryLanguage::Swedish => {
                f.debug_tuple("PrimaryLanguage::Swedish").finish()
              }
              PrimaryLanguage::Tamil => {
                f.debug_tuple("PrimaryLanguage::Tamil").finish()
              }
              PrimaryLanguage::Tatar => {
                f.debug_tuple("PrimaryLanguage::Tatar").finish()
              }
              PrimaryLanguage::Telugu => {
                f.debug_tuple("PrimaryLanguage::Telugu").finish()
              }
              PrimaryLanguage::Thai => {
                f.debug_tuple("PrimaryLanguage::Thai").finish()
              }
              PrimaryLanguage::Turkish => {
                f.debug_tuple("PrimaryLanguage::Turkish").finish()
              }
              PrimaryLanguage::Ukrainian => {
                f.debug_tuple("PrimaryLanguage::Ukrainian").finish()
              }
              PrimaryLanguage::Urdu => {
                f.debug_tuple("PrimaryLanguage::Urdu").finish()
              }
              PrimaryLanguage::Uzbek => {
                f.debug_tuple("PrimaryLanguage::Uzbek").finish()
              }
              PrimaryLanguage::Vietnamese => {
                f.debug_tuple("PrimaryLanguage::Vietnamese").finish()
              }
              PrimaryLanguage::Hid => {
                f.debug_tuple("PrimaryLanguage::Hid").finish()
              }
              PrimaryLanguage::Other(e) => {
                f.debug_tuple("PrimaryLanguage::Other").field(e).finish()
              }
            }
          }
        }
        #[derive(Clone, Copy)]
        pub enum SubLanguage {
          Standard,
          Classic,
          Traditional,
          Modern,
          Algeria,
          Argentina,
          Australia,
          Austria,
          Bahrain,
          Belgium,
          Belize,
          Bokmal,
          Bolivia,
          Brazil,
          BruneiDarussalam,
          Canada,
          Caribbean,
          Chile,
          China,
          Colombia,
          CostaRica,
          Cyrillic,
          DominicanRepublic,
          Ecuador,
          Egypt,
          ElSalvador,
          Finland,
          Guatemala,
          Honduras,
          HongKong,
          India,
          Iraq,
          Ireland,
          Jamaica,
          Johab,
          Jordan,
          Kuwait,
          Latin,
          Lebanon,
          Libya,
          Liechtenstein,
          Luxembourg,
          Macau,
          Malaysia,
          Mexico,
          Monaco,
          Morocco,
          Netherlands,
          NewZealand,
          Nicaragua,
          Nynorsk,
          Oman,
          Pakistan,
          Panama,
          Paraguay,
          Peru,
          Philippines,
          PuertoRico,
          Qatar,
          SaudiArabia,
          Singapore,
          SouthAfrica,
          Switzerland,
          Syria,
          Taiwan,
          Trinidad,
          Tunisia,
          UnitedArabEmirates,
          UnitedKingdom,
          UnitedStates,
          Uruguay,
          Venezuela,
          Yemen,
          Zimbabwe,
          UsageDataDescriptor,
          VendorDefined1,
          VendorDefined2,
          VendorDefined3,
          VendorDefined4,
          Other(u16),
        }
        impl ::core::fmt::Debug for SubLanguage {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              SubLanguage::Standard => {
                f.debug_tuple("SubLanguage::Standard").finish()
              }
              SubLanguage::Classic => {
                f.debug_tuple("SubLanguage::Classic").finish()
              }
              SubLanguage::Traditional => {
                f.debug_tuple("SubLanguage::Traditional").finish()
              }
              SubLanguage::Modern => {
                f.debug_tuple("SubLanguage::Modern").finish()
              }
              SubLanguage::Algeria => {
                f.debug_tuple("SubLanguage::Algeria").finish()
              }
              SubLanguage::Argentina => {
                f.debug_tuple("SubLanguage::Argentina").finish()
              }
              SubLanguage::Australia => {
                f.debug_tuple("SubLanguage::Australia").finish()
              }
              SubLanguage::Austria => {
                f.debug_tuple("SubLanguage::Austria").finish()
              }
              SubLanguage::Bahrain => {
                f.debug_tuple("SubLanguage::Bahrain").finish()
              }
              SubLanguage::Belgium => {
                f.debug_tuple("SubLanguage::Belgium").finish()
              }
              SubLanguage::Belize => {
                f.debug_tuple("SubLanguage::Belize").finish()
              }
              SubLanguage::Bokmal => {
                f.debug_tuple("SubLanguage::Bokmal").finish()
              }
              SubLanguage::Bolivia => {
                f.debug_tuple("SubLanguage::Bolivia").finish()
              }
              SubLanguage::Brazil => {
                f.debug_tuple("SubLanguage::Brazil").finish()
              }
              SubLanguage::BruneiDarussalam => {
                f.debug_tuple("SubLanguage::BruneiDarussalam").finish()
              }
              SubLanguage::Canada => {
                f.debug_tuple("SubLanguage::Canada").finish()
              }
              SubLanguage::Caribbean => {
                f.debug_tuple("SubLanguage::Caribbean").finish()
              }
              SubLanguage::Chile => {
                f.debug_tuple("SubLanguage::Chile").finish()
              }
              SubLanguage::China => {
                f.debug_tuple("SubLanguage::China").finish()
              }
              SubLanguage::Colombia => {
                f.debug_tuple("SubLanguage::Colombia").finish()
              }
              SubLanguage::CostaRica => {
                f.debug_tuple("SubLanguage::CostaRica").finish()
              }
              SubLanguage::Cyrillic => {
                f.debug_tuple("SubLanguage::Cyrillic").finish()
              }
              SubLanguage::DominicanRepublic => {
                f.debug_tuple("SubLanguage::DominicanRepublic").finish()
              }
              SubLanguage::Ecuador => {
                f.debug_tuple("SubLanguage::Ecuador").finish()
              }
              SubLanguage::Egypt => {
                f.debug_tuple("SubLanguage::Egypt").finish()
              }
              SubLanguage::ElSalvador => {
                f.debug_tuple("SubLanguage::ElSalvador").finish()
              }
              SubLanguage::Finland => {
                f.debug_tuple("SubLanguage::Finland").finish()
              }
              SubLanguage::Guatemala => {
                f.debug_tuple("SubLanguage::Guatemala").finish()
              }
              SubLanguage::Honduras => {
                f.debug_tuple("SubLanguage::Honduras").finish()
              }
              SubLanguage::HongKong => {
                f.debug_tuple("SubLanguage::HongKong").finish()
              }
              SubLanguage::India => {
                f.debug_tuple("SubLanguage::India").finish()
              }
              SubLanguage::Iraq => {
                f.debug_tuple("SubLanguage::Iraq").finish()
              }
              SubLanguage::Ireland => {
                f.debug_tuple("SubLanguage::Ireland").finish()
              }
              SubLanguage::Jamaica => {
                f.debug_tuple("SubLanguage::Jamaica").finish()
              }
              SubLanguage::Johab => {
                f.debug_tuple("SubLanguage::Johab").finish()
              }
              SubLanguage::Jordan => {
                f.debug_tuple("SubLanguage::Jordan").finish()
              }
              SubLanguage::Kuwait => {
                f.debug_tuple("SubLanguage::Kuwait").finish()
              }
              SubLanguage::Latin => {
                f.debug_tuple("SubLanguage::Latin").finish()
              }
              SubLanguage::Lebanon => {
                f.debug_tuple("SubLanguage::Lebanon").finish()
              }
              SubLanguage::Libya => {
                f.debug_tuple("SubLanguage::Libya").finish()
              }
              SubLanguage::Liechtenstein => {
                f.debug_tuple("SubLanguage::Liechtenstein").finish()
              }
              SubLanguage::Luxembourg => {
                f.debug_tuple("SubLanguage::Luxembourg").finish()
              }
              SubLanguage::Macau => {
                f.debug_tuple("SubLanguage::Macau").finish()
              }
              SubLanguage::Malaysia => {
                f.debug_tuple("SubLanguage::Malaysia").finish()
              }
              SubLanguage::Mexico => {
                f.debug_tuple("SubLanguage::Mexico").finish()
              }
              SubLanguage::Monaco => {
                f.debug_tuple("SubLanguage::Monaco").finish()
              }
              SubLanguage::Morocco => {
                f.debug_tuple("SubLanguage::Morocco").finish()
              }
              SubLanguage::Netherlands => {
                f.debug_tuple("SubLanguage::Netherlands").finish()
              }
              SubLanguage::NewZealand => {
                f.debug_tuple("SubLanguage::NewZealand").finish()
              }
              SubLanguage::Nicaragua => {
                f.debug_tuple("SubLanguage::Nicaragua").finish()
              }
              SubLanguage::Nynorsk => {
                f.debug_tuple("SubLanguage::Nynorsk").finish()
              }
              SubLanguage::Oman => {
                f.debug_tuple("SubLanguage::Oman").finish()
              }
              SubLanguage::Pakistan => {
                f.debug_tuple("SubLanguage::Pakistan").finish()
              }
              SubLanguage::Panama => {
                f.debug_tuple("SubLanguage::Panama").finish()
              }
              SubLanguage::Paraguay => {
                f.debug_tuple("SubLanguage::Paraguay").finish()
              }
              SubLanguage::Peru => {
                f.debug_tuple("SubLanguage::Peru").finish()
              }
              SubLanguage::Philippines => {
                f.debug_tuple("SubLanguage::Philippines").finish()
              }
              SubLanguage::PuertoRico => {
                f.debug_tuple("SubLanguage::PuertoRico").finish()
              }
              SubLanguage::Qatar => {
                f.debug_tuple("SubLanguage::Qatar").finish()
              }
              SubLanguage::SaudiArabia => {
                f.debug_tuple("SubLanguage::SaudiArabia").finish()
              }
              SubLanguage::Singapore => {
                f.debug_tuple("SubLanguage::Singapore").finish()
              }
              SubLanguage::SouthAfrica => {
                f.debug_tuple("SubLanguage::SouthAfrica").finish()
              }
              SubLanguage::Switzerland => {
                f.debug_tuple("SubLanguage::Switzerland").finish()
              }
              SubLanguage::Syria => {
                f.debug_tuple("SubLanguage::Syria").finish()
              }
              SubLanguage::Taiwan => {
                f.debug_tuple("SubLanguage::Taiwan").finish()
              }
              SubLanguage::Trinidad => {
                f.debug_tuple("SubLanguage::Trinidad").finish()
              }
              SubLanguage::Tunisia => {
                f.debug_tuple("SubLanguage::Tunisia").finish()
              }
              SubLanguage::UnitedArabEmirates => {
                f.debug_tuple("SubLanguage::UnitedArabEmirates").finish()
              }
              SubLanguage::UnitedKingdom => {
                f.debug_tuple("SubLanguage::UnitedKingdom").finish()
              }
              SubLanguage::UnitedStates => {
                f.debug_tuple("SubLanguage::UnitedStates").finish()
              }
              SubLanguage::Uruguay => {
                f.debug_tuple("SubLanguage::Uruguay").finish()
              }
              SubLanguage::Venezuela => {
                f.debug_tuple("SubLanguage::Venezuela").finish()
              }
              SubLanguage::Yemen => {
                f.debug_tuple("SubLanguage::Yemen").finish()
              }
              SubLanguage::Zimbabwe => {
                f.debug_tuple("SubLanguage::Zimbabwe").finish()
              }
              SubLanguage::UsageDataDescriptor => {
                f.debug_tuple("SubLanguage::UsageDataDescriptor").finish()
              }
              SubLanguage::VendorDefined1 => {
                f.debug_tuple("SubLanguage::VendorDefined1").finish()
              }
              SubLanguage::VendorDefined2 => {
                f.debug_tuple("SubLanguage::VendorDefined2").finish()
              }
              SubLanguage::VendorDefined3 => {
                f.debug_tuple("SubLanguage::VendorDefined3").finish()
              }
              SubLanguage::VendorDefined4 => {
                f.debug_tuple("SubLanguage::VendorDefined4").finish()
              }
              SubLanguage::Other(e) => {
                f.debug_tuple("SubLanguage::Other").field(e).finish()
              }
            }
          }
        }
        #[repr(C)]
        #[derive(Clone, Copy)]
        pub struct Language {
          pub id: u16,
          pub primary_language: PrimaryLanguage,
          pub sub_language: SubLanguage,
        }
        impl ::core::fmt::Debug for Language {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Language").field("id", &self.id).field("primary-language", &self.primary_language).field("sub-language", &self.sub_language).finish()
          }
        }
        #[doc(hidden)]

        macro_rules! __export_component_usb_types_0_2_1_cabi{
          ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

          };);
        }
        #[doc(hidden)]
        pub(crate) use __export_component_usb_types_0_2_1_cabi;

      }

      #[allow(dead_code, clippy::all)]
      pub mod descriptors {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
        use super::super::super::super::_rt;
        pub type EndpointDirection = super::super::super::super::exports::component::usb::types::EndpointDirection;
        pub type EndpointTransferType = super::super::super::super::exports::component::usb::types::EndpointTransferType;
        pub type EndpointSyncType = super::super::super::super::exports::component::usb::types::EndpointSyncType;
        pub type EndpointUsageType = super::super::super::super::exports::component::usb::types::EndpointUsageType;
        pub type Version = super::super::super::super::exports::component::usb::types::Version;
        #[repr(C)]
        #[derive(Clone, Copy)]
        pub struct EndpointDescriptor {
          pub address: u8,
          pub number: u8,
          pub direction: EndpointDirection,
          pub transfer_type: EndpointTransferType,
          pub max_packet_size: u16,
          pub sync_type: EndpointSyncType,
          pub usage_type: EndpointUsageType,
          pub polling_interval: u8,
          pub refresh_rate: u8,
          /// audio
          pub synch_address: u8,
        }
        impl ::core::fmt::Debug for EndpointDescriptor {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("EndpointDescriptor").field("address", &self.address).field("number", &self.number).field("direction", &self.direction).field("transfer-type", &self.transfer_type).field("max-packet-size", &self.max_packet_size).field("sync-type", &self.sync_type).field("usage-type", &self.usage_type).field("polling-interval", &self.polling_interval).field("refresh-rate", &self.refresh_rate).field("synch-address", &self.synch_address).finish()
          }
        }
        #[derive(Clone)]
        pub struct InterfaceDescriptor {
          pub interface_number: u8,
          pub setting_number: u8,
          pub class_code: u8,
          pub subclass_code: u8,
          pub protocol_code: u8,
          pub description: Option<u8>,
          pub num_endpoints: u8,
          pub endpoints: _rt::Vec::<EndpointDescriptor>,
        }
        impl ::core::fmt::Debug for InterfaceDescriptor {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("InterfaceDescriptor").field("interface-number", &self.interface_number).field("setting-number", &self.setting_number).field("class-code", &self.class_code).field("subclass-code", &self.subclass_code).field("protocol-code", &self.protocol_code).field("description", &self.description).field("num-endpoints", &self.num_endpoints).field("endpoints", &self.endpoints).finish()
          }
        }
        #[derive(Clone)]
        pub struct DeviceInterface {
          pub number: u8,
          pub interface_descriptors: _rt::Vec::<InterfaceDescriptor>,
        }
        impl ::core::fmt::Debug for DeviceInterface {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("DeviceInterface").field("number", &self.number).field("interface-descriptors", &self.interface_descriptors).finish()
          }
        }
        #[derive(Clone)]
        pub struct ConfigDescriptor {
          pub number: u8,
          pub max_power: u16,
          pub self_powered: bool,
          pub remote_wakeup: bool,
          pub description: Option<u8>,
          pub num_interfaces: u8,
          pub interfaces: _rt::Vec::<DeviceInterface>,
        }
        impl ::core::fmt::Debug for ConfigDescriptor {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("ConfigDescriptor").field("number", &self.number).field("max-power", &self.max_power).field("self-powered", &self.self_powered).field("remote-wakeup", &self.remote_wakeup).field("description", &self.description).field("num-interfaces", &self.num_interfaces).field("interfaces", &self.interfaces).finish()
          }
        }
        #[repr(C)]
        #[derive(Clone, Copy)]
        pub struct DeviceDescriptor {
          pub usb_version: Version,
          pub device_version: Version,
          pub manufacturer_string: Option<u8>,
          pub product_string: Option<u8>,
          pub serial_number_string: Option<u8>,
          pub class_code: u8,
          pub subclass_code: u8,
          pub protocol_code: u8,
          pub vendor_id: u16,
          pub product_id: u16,
          pub max_packet_size: u8,
          pub num_configurations: u8,
        }
        impl ::core::fmt::Debug for DeviceDescriptor {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("DeviceDescriptor").field("usb-version", &self.usb_version).field("device-version", &self.device_version).field("manufacturer-string", &self.manufacturer_string).field("product-string", &self.product_string).field("serial-number-string", &self.serial_number_string).field("class-code", &self.class_code).field("subclass-code", &self.subclass_code).field("protocol-code", &self.protocol_code).field("vendor-id", &self.vendor_id).field("product-id", &self.product_id).field("max-packet-size", &self.max_packet_size).field("num-configurations", &self.num_configurations).finish()
          }
        }
        #[doc(hidden)]

        macro_rules! __export_component_usb_descriptors_0_2_1_cabi{
          ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

          };);
        }
        #[doc(hidden)]
        pub(crate) use __export_component_usb_descriptors_0_2_1_cabi;

      }

      #[allow(dead_code, clippy::all)]
      pub mod usb {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
        use super::super::super::super::_rt;
        pub type DeviceDescriptor = super::super::super::super::exports::component::usb::descriptors::DeviceDescriptor;
        pub type ConfigDescriptor = super::super::super::super::exports::component::usb::descriptors::ConfigDescriptor;
        pub type Speed = super::super::super::super::exports::component::usb::types::Speed;
        pub type Duration = super::super::super::super::exports::component::usb::types::Duration;
        pub type DeviceHandleError = super::super::super::super::exports::component::usb::types::DeviceHandleError;
        pub type Language = super::super::super::super::exports::component::usb::types::Language;

        #[derive(Debug)]
        #[repr(transparent)]
        pub struct UsbDevice{
          handle: _rt::Resource<UsbDevice>,
        }

        type _UsbDeviceRep<T> = Option<T>;

        impl UsbDevice{
          /// Creates a new resource from the specified representation.
          ///
          /// This function will create a new resource handle by moving `val` onto
          /// the heap and then passing that heap pointer to the component model to
          /// create a handle. The owned handle is then returned as `UsbDevice`.
          pub fn new<T: GuestUsbDevice>(val: T) -> Self {
            Self::type_guard::<T>();
            let val: _UsbDeviceRep<T> = Some(val);
            let ptr: *mut _UsbDeviceRep<T> =
            _rt::Box::into_raw(_rt::Box::new(val));
            unsafe {
              Self::from_handle(T::_resource_new(ptr.cast()))
            }
          }

          /// Gets access to the underlying `T` which represents this resource.
          pub fn get<T: GuestUsbDevice>(&self) -> &T {
            let ptr = unsafe { &*self.as_ptr::<T>() };
            ptr.as_ref().unwrap()
          }

          /// Gets mutable access to the underlying `T` which represents this
          /// resource.
          pub fn get_mut<T: GuestUsbDevice>(&mut self) -> &mut T {
            let ptr = unsafe { &mut *self.as_ptr::<T>() };
            ptr.as_mut().unwrap()
          }

          /// Consumes this resource and returns the underlying `T`.
          pub fn into_inner<T: GuestUsbDevice>(self) -> T {
            let ptr = unsafe { &mut *self.as_ptr::<T>() };
            ptr.take().unwrap()
          }

          #[doc(hidden)]
          pub unsafe fn from_handle(handle: u32) -> Self {
            Self {
              handle: _rt::Resource::from_handle(handle),
            }
          }

          #[doc(hidden)]
          pub fn take_handle(&self) -> u32 {
            _rt::Resource::take_handle(&self.handle)
          }

          #[doc(hidden)]
          pub fn handle(&self) -> u32 {
            _rt::Resource::handle(&self.handle)
          }

          // It's theoretically possible to implement the `GuestUsbDevice` trait twice
          // so guard against using it with two different types here.
          #[doc(hidden)]
          fn type_guard<T: 'static>() {
            use core::any::TypeId;
            static mut LAST_TYPE: Option<TypeId> = None;
            unsafe {
              assert!(!cfg!(target_feature = "threads"));
              let id = TypeId::of::<T>();
              match LAST_TYPE {
                Some(ty) => assert!(ty == id, "cannot use two types with this resource type"),
                None => LAST_TYPE = Some(id),
              }
            }
          }

          #[doc(hidden)]
          pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
            Self::type_guard::<T>();
            let _ = _rt::Box::from_raw(handle as *mut _UsbDeviceRep<T>);
          }

          fn as_ptr<T: GuestUsbDevice>(&self) -> *mut _UsbDeviceRep<T> {
            UsbDevice::type_guard::<T>();
            T::_resource_rep(self.handle()).cast()
          }
        }

        /// A borrowed version of [`UsbDevice`] which represents a borrowed value
        /// with the lifetime `'a`.
        #[derive(Debug)]
        #[repr(transparent)]
        pub struct UsbDeviceBorrow<'a> {
          rep: *mut u8,
          _marker: core::marker::PhantomData<&'a UsbDevice>,
        }

        impl<'a> UsbDeviceBorrow<'a>{
          #[doc(hidden)]
          pub unsafe fn lift(rep: usize) -> Self {
            Self {
              rep: rep as *mut u8,
              _marker: core::marker::PhantomData,
            }
          }

          /// Gets access to the underlying `T` in this resource.
          pub fn get<T: GuestUsbDevice>(&self) -> &T {
            let ptr = unsafe { &mut *self.as_ptr::<T>() };
            ptr.as_ref().unwrap()
          }

          // NB: mutable access is not allowed due to the component model allowing
          // multiple borrows of the same resource.

          fn as_ptr<T: 'static>(&self) -> *mut _UsbDeviceRep<T> {
            UsbDevice::type_guard::<T>();
            self.rep.cast()
          }
        }


        unsafe impl _rt::WasmResource for UsbDevice{
          #[inline]
          unsafe fn drop(_handle: u32) {
            #[cfg(not(target_arch = "wasm32"))]
            unreachable!();

            #[cfg(target_arch = "wasm32")]
            {
              #[link(wasm_import_module = "[export]component:usb/usb@0.2.1")]
              extern "C" {
                #[link_name = "[resource-drop]usb-device"]
                fn drop(_: u32);
              }

              drop(_handle);
            }
          }
        }


        #[derive(Debug)]
        #[repr(transparent)]
        pub struct Context{
          handle: _rt::Resource<Context>,
        }

        type _ContextRep<T> = Option<T>;

        impl Context{
          /// Creates a new resource from the specified representation.
          ///
          /// This function will create a new resource handle by moving `val` onto
          /// the heap and then passing that heap pointer to the component model to
          /// create a handle. The owned handle is then returned as `Context`.
          pub fn new<T: GuestContext>(val: T) -> Self {
            Self::type_guard::<T>();
            let val: _ContextRep<T> = Some(val);
            let ptr: *mut _ContextRep<T> =
            _rt::Box::into_raw(_rt::Box::new(val));
            unsafe {
              Self::from_handle(T::_resource_new(ptr.cast()))
            }
          }

          /// Gets access to the underlying `T` which represents this resource.
          pub fn get<T: GuestContext>(&self) -> &T {
            let ptr = unsafe { &*self.as_ptr::<T>() };
            ptr.as_ref().unwrap()
          }

          /// Gets mutable access to the underlying `T` which represents this
          /// resource.
          pub fn get_mut<T: GuestContext>(&mut self) -> &mut T {
            let ptr = unsafe { &mut *self.as_ptr::<T>() };
            ptr.as_mut().unwrap()
          }

          /// Consumes this resource and returns the underlying `T`.
          pub fn into_inner<T: GuestContext>(self) -> T {
            let ptr = unsafe { &mut *self.as_ptr::<T>() };
            ptr.take().unwrap()
          }

          #[doc(hidden)]
          pub unsafe fn from_handle(handle: u32) -> Self {
            Self {
              handle: _rt::Resource::from_handle(handle),
            }
          }

          #[doc(hidden)]
          pub fn take_handle(&self) -> u32 {
            _rt::Resource::take_handle(&self.handle)
          }

          #[doc(hidden)]
          pub fn handle(&self) -> u32 {
            _rt::Resource::handle(&self.handle)
          }

          // It's theoretically possible to implement the `GuestContext` trait twice
          // so guard against using it with two different types here.
          #[doc(hidden)]
          fn type_guard<T: 'static>() {
            use core::any::TypeId;
            static mut LAST_TYPE: Option<TypeId> = None;
            unsafe {
              assert!(!cfg!(target_feature = "threads"));
              let id = TypeId::of::<T>();
              match LAST_TYPE {
                Some(ty) => assert!(ty == id, "cannot use two types with this resource type"),
                None => LAST_TYPE = Some(id),
              }
            }
          }

          #[doc(hidden)]
          pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
            Self::type_guard::<T>();
            let _ = _rt::Box::from_raw(handle as *mut _ContextRep<T>);
          }

          fn as_ptr<T: GuestContext>(&self) -> *mut _ContextRep<T> {
            Context::type_guard::<T>();
            T::_resource_rep(self.handle()).cast()
          }
        }

        /// A borrowed version of [`Context`] which represents a borrowed value
        /// with the lifetime `'a`.
        #[derive(Debug)]
        #[repr(transparent)]
        pub struct ContextBorrow<'a> {
          rep: *mut u8,
          _marker: core::marker::PhantomData<&'a Context>,
        }

        impl<'a> ContextBorrow<'a>{
          #[doc(hidden)]
          pub unsafe fn lift(rep: usize) -> Self {
            Self {
              rep: rep as *mut u8,
              _marker: core::marker::PhantomData,
            }
          }

          /// Gets access to the underlying `T` in this resource.
          pub fn get<T: GuestContext>(&self) -> &T {
            let ptr = unsafe { &mut *self.as_ptr::<T>() };
            ptr.as_ref().unwrap()
          }

          // NB: mutable access is not allowed due to the component model allowing
          // multiple borrows of the same resource.

          fn as_ptr<T: 'static>(&self) -> *mut _ContextRep<T> {
            Context::type_guard::<T>();
            self.rep.cast()
          }
        }


        unsafe impl _rt::WasmResource for Context{
          #[inline]
          unsafe fn drop(_handle: u32) {
            #[cfg(not(target_arch = "wasm32"))]
            unreachable!();

            #[cfg(target_arch = "wasm32")]
            {
              #[link(wasm_import_module = "[export]component:usb/usb@0.2.1")]
              extern "C" {
                #[link_name = "[resource-drop]context"]
                fn drop(_: u32);
              }

              drop(_handle);
            }
          }
        }


        #[derive(Debug)]
        #[repr(transparent)]
        pub struct DeviceHandle{
          handle: _rt::Resource<DeviceHandle>,
        }

        type _DeviceHandleRep<T> = Option<T>;

        impl DeviceHandle{
          /// Creates a new resource from the specified representation.
          ///
          /// This function will create a new resource handle by moving `val` onto
          /// the heap and then passing that heap pointer to the component model to
          /// create a handle. The owned handle is then returned as `DeviceHandle`.
          pub fn new<T: GuestDeviceHandle>(val: T) -> Self {
            Self::type_guard::<T>();
            let val: _DeviceHandleRep<T> = Some(val);
            let ptr: *mut _DeviceHandleRep<T> =
            _rt::Box::into_raw(_rt::Box::new(val));
            unsafe {
              Self::from_handle(T::_resource_new(ptr.cast()))
            }
          }

          /// Gets access to the underlying `T` which represents this resource.
          pub fn get<T: GuestDeviceHandle>(&self) -> &T {
            let ptr = unsafe { &*self.as_ptr::<T>() };
            ptr.as_ref().unwrap()
          }

          /// Gets mutable access to the underlying `T` which represents this
          /// resource.
          pub fn get_mut<T: GuestDeviceHandle>(&mut self) -> &mut T {
            let ptr = unsafe { &mut *self.as_ptr::<T>() };
            ptr.as_mut().unwrap()
          }

          /// Consumes this resource and returns the underlying `T`.
          pub fn into_inner<T: GuestDeviceHandle>(self) -> T {
            let ptr = unsafe { &mut *self.as_ptr::<T>() };
            ptr.take().unwrap()
          }

          #[doc(hidden)]
          pub unsafe fn from_handle(handle: u32) -> Self {
            Self {
              handle: _rt::Resource::from_handle(handle),
            }
          }

          #[doc(hidden)]
          pub fn take_handle(&self) -> u32 {
            _rt::Resource::take_handle(&self.handle)
          }

          #[doc(hidden)]
          pub fn handle(&self) -> u32 {
            _rt::Resource::handle(&self.handle)
          }

          // It's theoretically possible to implement the `GuestDeviceHandle` trait twice
          // so guard against using it with two different types here.
          #[doc(hidden)]
          fn type_guard<T: 'static>() {
            use core::any::TypeId;
            static mut LAST_TYPE: Option<TypeId> = None;
            unsafe {
              assert!(!cfg!(target_feature = "threads"));
              let id = TypeId::of::<T>();
              match LAST_TYPE {
                Some(ty) => assert!(ty == id, "cannot use two types with this resource type"),
                None => LAST_TYPE = Some(id),
              }
            }
          }

          #[doc(hidden)]
          pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
            Self::type_guard::<T>();
            let _ = _rt::Box::from_raw(handle as *mut _DeviceHandleRep<T>);
          }

          fn as_ptr<T: GuestDeviceHandle>(&self) -> *mut _DeviceHandleRep<T> {
            DeviceHandle::type_guard::<T>();
            T::_resource_rep(self.handle()).cast()
          }
        }

        /// A borrowed version of [`DeviceHandle`] which represents a borrowed value
        /// with the lifetime `'a`.
        #[derive(Debug)]
        #[repr(transparent)]
        pub struct DeviceHandleBorrow<'a> {
          rep: *mut u8,
          _marker: core::marker::PhantomData<&'a DeviceHandle>,
        }

        impl<'a> DeviceHandleBorrow<'a>{
          #[doc(hidden)]
          pub unsafe fn lift(rep: usize) -> Self {
            Self {
              rep: rep as *mut u8,
              _marker: core::marker::PhantomData,
            }
          }

          /// Gets access to the underlying `T` in this resource.
          pub fn get<T: GuestDeviceHandle>(&self) -> &T {
            let ptr = unsafe { &mut *self.as_ptr::<T>() };
            ptr.as_ref().unwrap()
          }

          // NB: mutable access is not allowed due to the component model allowing
          // multiple borrows of the same resource.

          fn as_ptr<T: 'static>(&self) -> *mut _DeviceHandleRep<T> {
            DeviceHandle::type_guard::<T>();
            self.rep.cast()
          }
        }


        unsafe impl _rt::WasmResource for DeviceHandle{
          #[inline]
          unsafe fn drop(_handle: u32) {
            #[cfg(not(target_arch = "wasm32"))]
            unreachable!();

            #[cfg(target_arch = "wasm32")]
            {
              #[link(wasm_import_module = "[export]component:usb/usb@0.2.1")]
              extern "C" {
                #[link_name = "[resource-drop]device-handle"]
                fn drop(_: u32);
              }

              drop(_handle);
            }
          }
        }

        #[doc(hidden)]
        #[allow(non_snake_case)]
        pub unsafe fn _export_method_usb_device_device_descriptor_cabi<T: GuestUsbDevice>(arg0: *mut u8,) -> *mut u8 {#[cfg(target_arch="wasm32")]
        _rt::run_ctors_once();let result0 = T::device_descriptor(UsbDeviceBorrow::lift(arg0 as u32 as usize).get());
        let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
        match result0 {
          Ok(e) => { {
            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
            let super::super::super::super::exports::component::usb::descriptors::DeviceDescriptor{ usb_version:usb_version2, device_version:device_version2, manufacturer_string:manufacturer_string2, product_string:product_string2, serial_number_string:serial_number_string2, class_code:class_code2, subclass_code:subclass_code2, protocol_code:protocol_code2, vendor_id:vendor_id2, product_id:product_id2, max_packet_size:max_packet_size2, num_configurations:num_configurations2, } = e;
            let super::super::super::super::exports::component::usb::types::Version{ major:major3, minor:minor3, subminor:subminor3, } = usb_version2;
            *ptr1.add(2).cast::<u8>() = (_rt::as_i32(major3)) as u8;
            *ptr1.add(3).cast::<u8>() = (_rt::as_i32(minor3)) as u8;
            *ptr1.add(4).cast::<u8>() = (_rt::as_i32(subminor3)) as u8;
            let super::super::super::super::exports::component::usb::types::Version{ major:major4, minor:minor4, subminor:subminor4, } = device_version2;
            *ptr1.add(5).cast::<u8>() = (_rt::as_i32(major4)) as u8;
            *ptr1.add(6).cast::<u8>() = (_rt::as_i32(minor4)) as u8;
            *ptr1.add(7).cast::<u8>() = (_rt::as_i32(subminor4)) as u8;
            match manufacturer_string2 {
              Some(e) => {
                *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                *ptr1.add(9).cast::<u8>() = (_rt::as_i32(e)) as u8;
              },
              None => {
                {
                  *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                }
              },
            };match product_string2 {
              Some(e) => {
                *ptr1.add(10).cast::<u8>() = (1i32) as u8;
                *ptr1.add(11).cast::<u8>() = (_rt::as_i32(e)) as u8;
              },
              None => {
                {
                  *ptr1.add(10).cast::<u8>() = (0i32) as u8;
                }
              },
            };match serial_number_string2 {
              Some(e) => {
                *ptr1.add(12).cast::<u8>() = (1i32) as u8;
                *ptr1.add(13).cast::<u8>() = (_rt::as_i32(e)) as u8;
              },
              None => {
                {
                  *ptr1.add(12).cast::<u8>() = (0i32) as u8;
                }
              },
            };*ptr1.add(14).cast::<u8>() = (_rt::as_i32(class_code2)) as u8;
            *ptr1.add(15).cast::<u8>() = (_rt::as_i32(subclass_code2)) as u8;
            *ptr1.add(16).cast::<u8>() = (_rt::as_i32(protocol_code2)) as u8;
            *ptr1.add(18).cast::<u16>() = (_rt::as_i32(vendor_id2)) as u16;
            *ptr1.add(20).cast::<u16>() = (_rt::as_i32(product_id2)) as u16;
            *ptr1.add(22).cast::<u8>() = (_rt::as_i32(max_packet_size2)) as u8;
            *ptr1.add(23).cast::<u8>() = (_rt::as_i32(num_configurations2)) as u8;
          } },
          Err(_) => { {
            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
          } },
        };ptr1
      }
      #[doc(hidden)]
      #[allow(non_snake_case)]
      pub unsafe fn _export_method_usb_device_config_descriptor_cabi<T: GuestUsbDevice>(arg0: *mut u8,) -> *mut u8 {#[cfg(target_arch="wasm32")]
      _rt::run_ctors_once();let result0 = T::config_descriptor(UsbDeviceBorrow::lift(arg0 as u32 as usize).get());
      let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
      match result0 {
        Ok(e) => { {
          *ptr1.add(0).cast::<u8>() = (0i32) as u8;
          let super::super::super::super::exports::component::usb::descriptors::ConfigDescriptor{ number:number2, max_power:max_power2, self_powered:self_powered2, remote_wakeup:remote_wakeup2, description:description2, num_interfaces:num_interfaces2, interfaces:interfaces2, } = e;
          *ptr1.add(4).cast::<u8>() = (_rt::as_i32(number2)) as u8;
          *ptr1.add(6).cast::<u16>() = (_rt::as_i32(max_power2)) as u16;
          *ptr1.add(8).cast::<u8>() = (match self_powered2 { true => 1, false => 0 }) as u8;
          *ptr1.add(9).cast::<u8>() = (match remote_wakeup2 { true => 1, false => 0 }) as u8;
          match description2 {
            Some(e) => {
              *ptr1.add(10).cast::<u8>() = (1i32) as u8;
              *ptr1.add(11).cast::<u8>() = (_rt::as_i32(e)) as u8;
            },
            None => {
              {
                *ptr1.add(10).cast::<u8>() = (0i32) as u8;
              }
            },
          };*ptr1.add(12).cast::<u8>() = (_rt::as_i32(num_interfaces2)) as u8;
          let vec8 = interfaces2;
          let len8 = vec8.len();
          let layout8 = _rt::alloc::Layout::from_size_align_unchecked(vec8.len() * 12, 4);
          let result8 = if layout8.size() != 0 {
            let ptr = _rt::alloc::alloc(layout8).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout8);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec8.into_iter().enumerate() {
            let base = result8.add(i * 12);
            {
              let super::super::super::super::exports::component::usb::descriptors::DeviceInterface{ number:number3, interface_descriptors:interface_descriptors3, } = e;
              *base.add(0).cast::<u8>() = (_rt::as_i32(number3)) as u8;
              let vec7 = interface_descriptors3;
              let len7 = vec7.len();
              let layout7 = _rt::alloc::Layout::from_size_align_unchecked(vec7.len() * 16, 4);
              let result7 = if layout7.size() != 0 {
                let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
                if ptr.is_null()
                {
                  _rt::alloc::handle_alloc_error(layout7);
                }
                ptr
              }else {{
                ::core::ptr::null_mut()
              }};
              for (i, e) in vec7.into_iter().enumerate() {
                let base = result7.add(i * 16);
                {
                  let super::super::super::super::exports::component::usb::descriptors::InterfaceDescriptor{ interface_number:interface_number4, setting_number:setting_number4, class_code:class_code4, subclass_code:subclass_code4, protocol_code:protocol_code4, description:description4, num_endpoints:num_endpoints4, endpoints:endpoints4, } = e;
                  *base.add(0).cast::<u8>() = (_rt::as_i32(interface_number4)) as u8;
                  *base.add(1).cast::<u8>() = (_rt::as_i32(setting_number4)) as u8;
                  *base.add(2).cast::<u8>() = (_rt::as_i32(class_code4)) as u8;
                  *base.add(3).cast::<u8>() = (_rt::as_i32(subclass_code4)) as u8;
                  *base.add(4).cast::<u8>() = (_rt::as_i32(protocol_code4)) as u8;
                  match description4 {
                    Some(e) => {
                      *base.add(5).cast::<u8>() = (1i32) as u8;
                      *base.add(6).cast::<u8>() = (_rt::as_i32(e)) as u8;
                    },
                    None => {
                      {
                        *base.add(5).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };*base.add(7).cast::<u8>() = (_rt::as_i32(num_endpoints4)) as u8;
                  let vec6 = endpoints4;
                  let len6 = vec6.len();
                  let layout6 = _rt::alloc::Layout::from_size_align_unchecked(vec6.len() * 12, 2);
                  let result6 = if layout6.size() != 0 {
                    let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
                    if ptr.is_null()
                    {
                      _rt::alloc::handle_alloc_error(layout6);
                    }
                    ptr
                  }else {{
                    ::core::ptr::null_mut()
                  }};
                  for (i, e) in vec6.into_iter().enumerate() {
                    let base = result6.add(i * 12);
                    {
                      let super::super::super::super::exports::component::usb::descriptors::EndpointDescriptor{ address:address5, number:number5, direction:direction5, transfer_type:transfer_type5, max_packet_size:max_packet_size5, sync_type:sync_type5, usage_type:usage_type5, polling_interval:polling_interval5, refresh_rate:refresh_rate5, synch_address:synch_address5, } = e;
                      *base.add(0).cast::<u8>() = (_rt::as_i32(address5)) as u8;
                      *base.add(1).cast::<u8>() = (_rt::as_i32(number5)) as u8;
                      *base.add(2).cast::<u8>() = (direction5.clone() as i32) as u8;
                      *base.add(3).cast::<u8>() = (transfer_type5.clone() as i32) as u8;
                      *base.add(4).cast::<u16>() = (_rt::as_i32(max_packet_size5)) as u16;
                      *base.add(6).cast::<u8>() = (sync_type5.clone() as i32) as u8;
                      *base.add(7).cast::<u8>() = (usage_type5.clone() as i32) as u8;
                      *base.add(8).cast::<u8>() = (_rt::as_i32(polling_interval5)) as u8;
                      *base.add(9).cast::<u8>() = (_rt::as_i32(refresh_rate5)) as u8;
                      *base.add(10).cast::<u8>() = (_rt::as_i32(synch_address5)) as u8;
                    }
                  }
                  *base.add(12).cast::<usize>() = len6;
                  *base.add(8).cast::<*mut u8>() = result6;
                }
              }
              *base.add(8).cast::<usize>() = len7;
              *base.add(4).cast::<*mut u8>() = result7;
            }
          }
          *ptr1.add(20).cast::<usize>() = len8;
          *ptr1.add(16).cast::<*mut u8>() = result8;
        } },
        Err(_) => { {
          *ptr1.add(0).cast::<u8>() = (1i32) as u8;
        } },
      };ptr1
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    pub unsafe fn __post_return_method_usb_device_config_descriptor<T: GuestUsbDevice>(arg0: *mut u8,) {
      let l0 = i32::from(*arg0.add(0).cast::<u8>());
      match l0 {
        0 => {
          let l7 = *arg0.add(16).cast::<*mut u8>();
          let l8 = *arg0.add(20).cast::<usize>();
          let base9 = l7;
          let len9 = l8;
          for i in 0..len9 {
            let base = base9.add(i * 12);
            {
              let l4 = *base.add(4).cast::<*mut u8>();
              let l5 = *base.add(8).cast::<usize>();
              let base6 = l4;
              let len6 = l5;
              for i in 0..len6 {
                let base = base6.add(i * 16);
                {
                  let l1 = *base.add(8).cast::<*mut u8>();
                  let l2 = *base.add(12).cast::<usize>();
                  let base3 = l1;
                  let len3 = l2;
                  _rt::cabi_dealloc(base3, len3 * 12, 2);
                }
              }
              _rt::cabi_dealloc(base6, len6 * 16, 4);
            }
          }
          _rt::cabi_dealloc(base9, len9 * 12, 4);
        },
        _ => (),
      }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    pub unsafe fn _export_method_usb_device_bus_number_cabi<T: GuestUsbDevice>(arg0: *mut u8,) -> i32 {#[cfg(target_arch="wasm32")]
    _rt::run_ctors_once();let result0 = T::bus_number(UsbDeviceBorrow::lift(arg0 as u32 as usize).get());
    _rt::as_i32(result0)
  }
  #[doc(hidden)]
  #[allow(non_snake_case)]
  pub unsafe fn _export_method_usb_device_address_cabi<T: GuestUsbDevice>(arg0: *mut u8,) -> i32 {#[cfg(target_arch="wasm32")]
  _rt::run_ctors_once();let result0 = T::address(UsbDeviceBorrow::lift(arg0 as u32 as usize).get());
  _rt::as_i32(result0)
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_usb_device_speed_cabi<T: GuestUsbDevice>(arg0: *mut u8,) -> i32 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::speed(UsbDeviceBorrow::lift(arg0 as u32 as usize).get());
result0.clone() as i32
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_usb_device_open_cabi<T: GuestUsbDevice>(arg0: *mut u8,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::open(UsbDeviceBorrow::lift(arg0 as u32 as usize).get());
let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result0 {
  Ok(e) => { {
    *ptr1.add(0).cast::<u8>() = (0i32) as u8;
    *ptr1.add(4).cast::<i32>() = (e).take_handle() as i32;
  } },
  Err(_) => { {
    *ptr1.add(0).cast::<u8>() = (1i32) as u8;
  } },
};ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_usb_device_port_number_cabi<T: GuestUsbDevice>(arg0: *mut u8,) -> i32 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::port_number(UsbDeviceBorrow::lift(arg0 as u32 as usize).get());
_rt::as_i32(result0)
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_context_devices_cabi<T: GuestContext>(arg0: *mut u8,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::devices(ContextBorrow::lift(arg0 as u32 as usize).get());
let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result0 {
  Ok(e) => { {
    *ptr1.add(0).cast::<u8>() = (0i32) as u8;
    let vec2 = e;
    let len2 = vec2.len();
    let layout2 = _rt::alloc::Layout::from_size_align_unchecked(vec2.len() * 4, 4);
    let result2 = if layout2.size() != 0 {
      let ptr = _rt::alloc::alloc(layout2).cast::<u8>();
      if ptr.is_null()
      {
        _rt::alloc::handle_alloc_error(layout2);
      }
      ptr
    }else {{
      ::core::ptr::null_mut()
    }};
    for (i, e) in vec2.into_iter().enumerate() {
      let base = result2.add(i * 4);
      {
        *base.add(0).cast::<i32>() = (e).take_handle() as i32;
      }
    }
    *ptr1.add(8).cast::<usize>() = len2;
    *ptr1.add(4).cast::<*mut u8>() = result2;
  } },
  Err(_) => { {
    *ptr1.add(0).cast::<u8>() = (1i32) as u8;
  } },
};ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_method_context_devices<T: GuestContext>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => {
      let l1 = *arg0.add(4).cast::<*mut u8>();
      let l2 = *arg0.add(8).cast::<usize>();
      let base3 = l1;
      let len3 = l2;
      _rt::cabi_dealloc(base3, len3 * 4, 4);
    },
    _ => (),
  }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_context_open_device_with_vid_pid_cabi<T: GuestContext>(arg0: *mut u8,arg1: i32,arg2: i32,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::open_device_with_vid_pid(ContextBorrow::lift(arg0 as u32 as usize).get(), arg1 as u16, arg2 as u16);
let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result0 {
  Some(e) => {
    *ptr1.add(0).cast::<u8>() = (1i32) as u8;
    *ptr1.add(4).cast::<i32>() = (e).take_handle() as i32;
  },
  None => {
    {
      *ptr1.add(0).cast::<u8>() = (0i32) as u8;
    }
  },
};ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_device_cabi<T: GuestDeviceHandle>(arg0: *mut u8,) -> i32 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::device(DeviceHandleBorrow::lift(arg0 as u32 as usize).get());
(result0).take_handle() as i32
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_active_configuration_cabi<T: GuestDeviceHandle>(arg0: *mut u8,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::active_configuration(DeviceHandleBorrow::lift(arg0 as u32 as usize).get());
let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result0 {
  Ok(e) => { {
    *ptr1.add(0).cast::<u8>() = (0i32) as u8;
    *ptr1.add(1).cast::<u8>() = (_rt::as_i32(e)) as u8;
  } },
  Err(_) => { {
    *ptr1.add(0).cast::<u8>() = (1i32) as u8;
  } },
};ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_set_active_configuration_cabi<T: GuestDeviceHandle>(arg0: *mut u8,arg1: i32,) -> i32 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::set_active_configuration(DeviceHandleBorrow::lift(arg0 as u32 as usize).get(), arg1 as u8);
let result1 = match result0 {
  Ok(_) => { 0i32 },
  Err(_) => { 1i32 },
};result1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_unconfigure_cabi<T: GuestDeviceHandle>(arg0: *mut u8,) -> i32 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::unconfigure(DeviceHandleBorrow::lift(arg0 as u32 as usize).get());
let result1 = match result0 {
  Ok(_) => { 0i32 },
  Err(_) => { 1i32 },
};result1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_reset_cabi<T: GuestDeviceHandle>(arg0: *mut u8,) -> i32 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::reset(DeviceHandleBorrow::lift(arg0 as u32 as usize).get());
let result1 = match result0 {
  Ok(_) => { 0i32 },
  Err(_) => { 1i32 },
};result1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_clear_halt_cabi<T: GuestDeviceHandle>(arg0: *mut u8,arg1: i32,) -> i32 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::clear_halt(DeviceHandleBorrow::lift(arg0 as u32 as usize).get(), arg1 as u8);
let result1 = match result0 {
  Ok(_) => { 0i32 },
  Err(_) => { 1i32 },
};result1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_kernel_driver_active_cabi<T: GuestDeviceHandle>(arg0: *mut u8,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::kernel_driver_active(DeviceHandleBorrow::lift(arg0 as u32 as usize).get());
let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result0 {
  Ok(e) => { {
    *ptr1.add(0).cast::<u8>() = (0i32) as u8;
    *ptr1.add(1).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
  } },
  Err(_) => { {
    *ptr1.add(0).cast::<u8>() = (1i32) as u8;
  } },
};ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_detach_kernel_driver_cabi<T: GuestDeviceHandle>(arg0: *mut u8,) -> i32 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::detach_kernel_driver(DeviceHandleBorrow::lift(arg0 as u32 as usize).get());
let result1 = match result0 {
  Ok(_) => { 0i32 },
  Err(_) => { 1i32 },
};result1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_attach_kernel_driver_cabi<T: GuestDeviceHandle>(arg0: *mut u8,) -> i32 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::attach_kernel_driver(DeviceHandleBorrow::lift(arg0 as u32 as usize).get());
let result1 = match result0 {
  Ok(_) => { 0i32 },
  Err(_) => { 1i32 },
};result1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_set_auto_attach_detach_kernel_driver_cabi<T: GuestDeviceHandle>(arg0: *mut u8,arg1: i32,) -> i32 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::set_auto_attach_detach_kernel_driver(DeviceHandleBorrow::lift(arg0 as u32 as usize).get(), _rt::bool_lift(arg1 as u8));
let result1 = match result0 {
  Ok(_) => { 0i32 },
  Err(_) => { 1i32 },
};result1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_claim_interface_cabi<T: GuestDeviceHandle>(arg0: *mut u8,arg1: i32,) -> i32 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::claim_interface(DeviceHandleBorrow::lift(arg0 as u32 as usize).get(), arg1 as u8);
let result1 = match result0 {
  Ok(_) => { 0i32 },
  Err(_) => { 1i32 },
};result1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_release_interface_cabi<T: GuestDeviceHandle>(arg0: *mut u8,arg1: i32,) -> i32 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::release_interface(DeviceHandleBorrow::lift(arg0 as u32 as usize).get(), arg1 as u8);
let result1 = match result0 {
  Ok(_) => { 0i32 },
  Err(_) => { 1i32 },
};result1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_set_interface_alt_setting_cabi<T: GuestDeviceHandle>(arg0: *mut u8,arg1: i32,arg2: i32,) -> i32 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::set_interface_alt_setting(DeviceHandleBorrow::lift(arg0 as u32 as usize).get(), arg1 as u8, arg2 as u8);
let result1 = match result0 {
  Ok(_) => { 0i32 },
  Err(_) => { 1i32 },
};result1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_read_interrupt_cabi<T: GuestDeviceHandle>(arg0: *mut u8,arg1: i32,arg2: i64,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::read_interrupt(DeviceHandleBorrow::lift(arg0 as u32 as usize).get(), arg1 as u8, arg2 as u64);
let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result0 {
  Ok(e) => { {
    *ptr1.add(0).cast::<u8>() = (0i32) as u8;
    let (t2_0, t2_1, ) = e;
    *ptr1.add(8).cast::<i64>() = _rt::as_i64(t2_0);
    let vec3 = (t2_1).into_boxed_slice();
    let ptr3 = vec3.as_ptr().cast::<u8>();
    let len3 = vec3.len();
    ::core::mem::forget(vec3);
    *ptr1.add(20).cast::<usize>() = len3;
    *ptr1.add(16).cast::<*mut u8>() = ptr3.cast_mut();
  } },
  Err(e) => { {
    *ptr1.add(0).cast::<u8>() = (1i32) as u8;
    *ptr1.add(8).cast::<u8>() = (e.clone() as i32) as u8;
  } },
};ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_method_device_handle_read_interrupt<T: GuestDeviceHandle>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => {
      let l1 = *arg0.add(16).cast::<*mut u8>();
      let l2 = *arg0.add(20).cast::<usize>();
      let base3 = l1;
      let len3 = l2;
      _rt::cabi_dealloc(base3, len3 * 1, 1);
    },
    _ => (),
  }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_write_interrupt_cabi<T: GuestDeviceHandle>(arg0: *mut u8,arg1: i32,arg2: *mut u8,arg3: usize,arg4: i64,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let len0 = arg3;
let result1 = T::write_interrupt(DeviceHandleBorrow::lift(arg0 as u32 as usize).get(), arg1 as u8, _rt::Vec::from_raw_parts(arg2.cast(), len0, len0), arg4 as u64);
let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result1 {
  Ok(e) => { {
    *ptr2.add(0).cast::<u8>() = (0i32) as u8;
    *ptr2.add(8).cast::<i64>() = _rt::as_i64(e);
  } },
  Err(e) => { {
    *ptr2.add(0).cast::<u8>() = (1i32) as u8;
    *ptr2.add(8).cast::<u8>() = (e.clone() as i32) as u8;
  } },
};ptr2
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_read_bulk_cabi<T: GuestDeviceHandle>(arg0: *mut u8,arg1: i32,arg2: i64,arg3: i64,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::read_bulk(DeviceHandleBorrow::lift(arg0 as u32 as usize).get(), arg1 as u8, arg2 as u64, arg3 as u64);
let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result0 {
  Ok(e) => { {
    *ptr1.add(0).cast::<u8>() = (0i32) as u8;
    let (t2_0, t2_1, ) = e;
    *ptr1.add(8).cast::<i64>() = _rt::as_i64(t2_0);
    let vec3 = (t2_1).into_boxed_slice();
    let ptr3 = vec3.as_ptr().cast::<u8>();
    let len3 = vec3.len();
    ::core::mem::forget(vec3);
    *ptr1.add(20).cast::<usize>() = len3;
    *ptr1.add(16).cast::<*mut u8>() = ptr3.cast_mut();
  } },
  Err(e) => { {
    *ptr1.add(0).cast::<u8>() = (1i32) as u8;
    *ptr1.add(8).cast::<u8>() = (e.clone() as i32) as u8;
  } },
};ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_method_device_handle_read_bulk<T: GuestDeviceHandle>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => {
      let l1 = *arg0.add(16).cast::<*mut u8>();
      let l2 = *arg0.add(20).cast::<usize>();
      let base3 = l1;
      let len3 = l2;
      _rt::cabi_dealloc(base3, len3 * 1, 1);
    },
    _ => (),
  }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_write_bulk_cabi<T: GuestDeviceHandle>(arg0: *mut u8,arg1: i32,arg2: *mut u8,arg3: usize,arg4: i64,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let len0 = arg3;
let result1 = T::write_bulk(DeviceHandleBorrow::lift(arg0 as u32 as usize).get(), arg1 as u8, _rt::Vec::from_raw_parts(arg2.cast(), len0, len0), arg4 as u64);
let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result1 {
  Ok(e) => { {
    *ptr2.add(0).cast::<u8>() = (0i32) as u8;
    *ptr2.add(8).cast::<i64>() = _rt::as_i64(e);
  } },
  Err(e) => { {
    *ptr2.add(0).cast::<u8>() = (1i32) as u8;
    *ptr2.add(8).cast::<u8>() = (e.clone() as i32) as u8;
  } },
};ptr2
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_read_control_cabi<T: GuestDeviceHandle>(arg0: *mut u8,arg1: i32,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i64,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::read_control(DeviceHandleBorrow::lift(arg0 as u32 as usize).get(), arg1 as u8, arg2 as u8, arg3 as u16, arg4 as u16, arg5 as u16, arg6 as u64);
let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result0 {
  Ok(e) => { {
    *ptr1.add(0).cast::<u8>() = (0i32) as u8;
    let (t2_0, t2_1, ) = e;
    *ptr1.add(8).cast::<i64>() = _rt::as_i64(t2_0);
    let vec3 = (t2_1).into_boxed_slice();
    let ptr3 = vec3.as_ptr().cast::<u8>();
    let len3 = vec3.len();
    ::core::mem::forget(vec3);
    *ptr1.add(20).cast::<usize>() = len3;
    *ptr1.add(16).cast::<*mut u8>() = ptr3.cast_mut();
  } },
  Err(e) => { {
    *ptr1.add(0).cast::<u8>() = (1i32) as u8;
    *ptr1.add(8).cast::<u8>() = (e.clone() as i32) as u8;
  } },
};ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_method_device_handle_read_control<T: GuestDeviceHandle>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => {
      let l1 = *arg0.add(16).cast::<*mut u8>();
      let l2 = *arg0.add(20).cast::<usize>();
      let base3 = l1;
      let len3 = l2;
      _rt::cabi_dealloc(base3, len3 * 1, 1);
    },
    _ => (),
  }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_write_control_cabi<T: GuestDeviceHandle>(arg0: *mut u8,arg1: i32,arg2: i32,arg3: i32,arg4: i32,arg5: *mut u8,arg6: usize,arg7: i64,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let len0 = arg6;
let result1 = T::write_control(DeviceHandleBorrow::lift(arg0 as u32 as usize).get(), arg1 as u8, arg2 as u8, arg3 as u16, arg4 as u16, _rt::Vec::from_raw_parts(arg5.cast(), len0, len0), arg7 as u64);
let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result1 {
  Ok(e) => { {
    *ptr2.add(0).cast::<u8>() = (0i32) as u8;
    *ptr2.add(8).cast::<i64>() = _rt::as_i64(e);
  } },
  Err(e) => { {
    *ptr2.add(0).cast::<u8>() = (1i32) as u8;
    *ptr2.add(8).cast::<u8>() = (e.clone() as i32) as u8;
  } },
};ptr2
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_read_languages_cabi<T: GuestDeviceHandle>(arg0: *mut u8,arg1: i64,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::read_languages(DeviceHandleBorrow::lift(arg0 as u32 as usize).get(), arg1 as u64);
let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result0 {
  Ok(e) => { {
    *ptr1.add(0).cast::<u8>() = (0i32) as u8;
    let vec5 = e;
    let len5 = vec5.len();
    let layout5 = _rt::alloc::Layout::from_size_align_unchecked(vec5.len() * 10, 2);
    let result5 = if layout5.size() != 0 {
      let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
      if ptr.is_null()
      {
        _rt::alloc::handle_alloc_error(layout5);
      }
      ptr
    }else {{
      ::core::ptr::null_mut()
    }};
    for (i, e) in vec5.into_iter().enumerate() {
      let base = result5.add(i * 10);
      {
        let super::super::super::super::exports::component::usb::types::Language{ id:id2, primary_language:primary_language2, sub_language:sub_language2, } = e;
        *base.add(0).cast::<u16>() = (_rt::as_i32(id2)) as u16;
        use super::super::super::super::exports::component::usb::types::PrimaryLanguage as V3;
        match primary_language2 {
          V3::Afrikaans=> {
            {
              *base.add(2).cast::<u8>() = (0i32) as u8;
            }
          }
          V3::Albanian=> {
            {
              *base.add(2).cast::<u8>() = (1i32) as u8;
            }
          }
          V3::Arabic=> {
            {
              *base.add(2).cast::<u8>() = (2i32) as u8;
            }
          }
          V3::Armenian=> {
            {
              *base.add(2).cast::<u8>() = (3i32) as u8;
            }
          }
          V3::Assamese=> {
            {
              *base.add(2).cast::<u8>() = (4i32) as u8;
            }
          }
          V3::Azeri=> {
            {
              *base.add(2).cast::<u8>() = (5i32) as u8;
            }
          }
          V3::Basque=> {
            {
              *base.add(2).cast::<u8>() = (6i32) as u8;
            }
          }
          V3::Belarussian=> {
            {
              *base.add(2).cast::<u8>() = (7i32) as u8;
            }
          }
          V3::Bengali=> {
            {
              *base.add(2).cast::<u8>() = (8i32) as u8;
            }
          }
          V3::Bulgarian=> {
            {
              *base.add(2).cast::<u8>() = (9i32) as u8;
            }
          }
          V3::Burmese=> {
            {
              *base.add(2).cast::<u8>() = (10i32) as u8;
            }
          }
          V3::Catalan=> {
            {
              *base.add(2).cast::<u8>() = (11i32) as u8;
            }
          }
          V3::Chinese=> {
            {
              *base.add(2).cast::<u8>() = (12i32) as u8;
            }
          }
          V3::Croatian=> {
            {
              *base.add(2).cast::<u8>() = (13i32) as u8;
            }
          }
          V3::Czech=> {
            {
              *base.add(2).cast::<u8>() = (14i32) as u8;
            }
          }
          V3::Danish=> {
            {
              *base.add(2).cast::<u8>() = (15i32) as u8;
            }
          }
          V3::Dutch=> {
            {
              *base.add(2).cast::<u8>() = (16i32) as u8;
            }
          }
          V3::English=> {
            {
              *base.add(2).cast::<u8>() = (17i32) as u8;
            }
          }
          V3::Estonian=> {
            {
              *base.add(2).cast::<u8>() = (18i32) as u8;
            }
          }
          V3::Faeroese=> {
            {
              *base.add(2).cast::<u8>() = (19i32) as u8;
            }
          }
          V3::Farsi=> {
            {
              *base.add(2).cast::<u8>() = (20i32) as u8;
            }
          }
          V3::Finnish=> {
            {
              *base.add(2).cast::<u8>() = (21i32) as u8;
            }
          }
          V3::French=> {
            {
              *base.add(2).cast::<u8>() = (22i32) as u8;
            }
          }
          V3::Georgian=> {
            {
              *base.add(2).cast::<u8>() = (23i32) as u8;
            }
          }
          V3::German=> {
            {
              *base.add(2).cast::<u8>() = (24i32) as u8;
            }
          }
          V3::Greek=> {
            {
              *base.add(2).cast::<u8>() = (25i32) as u8;
            }
          }
          V3::Gujarati=> {
            {
              *base.add(2).cast::<u8>() = (26i32) as u8;
            }
          }
          V3::Hebrew=> {
            {
              *base.add(2).cast::<u8>() = (27i32) as u8;
            }
          }
          V3::Hindi=> {
            {
              *base.add(2).cast::<u8>() = (28i32) as u8;
            }
          }
          V3::Hungarian=> {
            {
              *base.add(2).cast::<u8>() = (29i32) as u8;
            }
          }
          V3::Icelandic=> {
            {
              *base.add(2).cast::<u8>() = (30i32) as u8;
            }
          }
          V3::Indonesian=> {
            {
              *base.add(2).cast::<u8>() = (31i32) as u8;
            }
          }
          V3::Italian=> {
            {
              *base.add(2).cast::<u8>() = (32i32) as u8;
            }
          }
          V3::Japanese=> {
            {
              *base.add(2).cast::<u8>() = (33i32) as u8;
            }
          }
          V3::Kannada=> {
            {
              *base.add(2).cast::<u8>() = (34i32) as u8;
            }
          }
          V3::Kashmiri=> {
            {
              *base.add(2).cast::<u8>() = (35i32) as u8;
            }
          }
          V3::Kazakh=> {
            {
              *base.add(2).cast::<u8>() = (36i32) as u8;
            }
          }
          V3::Konkani=> {
            {
              *base.add(2).cast::<u8>() = (37i32) as u8;
            }
          }
          V3::Korean=> {
            {
              *base.add(2).cast::<u8>() = (38i32) as u8;
            }
          }
          V3::Latvian=> {
            {
              *base.add(2).cast::<u8>() = (39i32) as u8;
            }
          }
          V3::Lithuanian=> {
            {
              *base.add(2).cast::<u8>() = (40i32) as u8;
            }
          }
          V3::Macedonian=> {
            {
              *base.add(2).cast::<u8>() = (41i32) as u8;
            }
          }
          V3::Malay=> {
            {
              *base.add(2).cast::<u8>() = (42i32) as u8;
            }
          }
          V3::Malayalam=> {
            {
              *base.add(2).cast::<u8>() = (43i32) as u8;
            }
          }
          V3::Manipuri=> {
            {
              *base.add(2).cast::<u8>() = (44i32) as u8;
            }
          }
          V3::Marathi=> {
            {
              *base.add(2).cast::<u8>() = (45i32) as u8;
            }
          }
          V3::Nepali=> {
            {
              *base.add(2).cast::<u8>() = (46i32) as u8;
            }
          }
          V3::Norwegian=> {
            {
              *base.add(2).cast::<u8>() = (47i32) as u8;
            }
          }
          V3::Oriya=> {
            {
              *base.add(2).cast::<u8>() = (48i32) as u8;
            }
          }
          V3::Polish=> {
            {
              *base.add(2).cast::<u8>() = (49i32) as u8;
            }
          }
          V3::Portuguese=> {
            {
              *base.add(2).cast::<u8>() = (50i32) as u8;
            }
          }
          V3::Punjabi=> {
            {
              *base.add(2).cast::<u8>() = (51i32) as u8;
            }
          }
          V3::Romanian=> {
            {
              *base.add(2).cast::<u8>() = (52i32) as u8;
            }
          }
          V3::Russian=> {
            {
              *base.add(2).cast::<u8>() = (53i32) as u8;
            }
          }
          V3::Sanskrit=> {
            {
              *base.add(2).cast::<u8>() = (54i32) as u8;
            }
          }
          V3::Serbian=> {
            {
              *base.add(2).cast::<u8>() = (55i32) as u8;
            }
          }
          V3::Sindhi=> {
            {
              *base.add(2).cast::<u8>() = (56i32) as u8;
            }
          }
          V3::Slovak=> {
            {
              *base.add(2).cast::<u8>() = (57i32) as u8;
            }
          }
          V3::Slovenian=> {
            {
              *base.add(2).cast::<u8>() = (58i32) as u8;
            }
          }
          V3::Spanish=> {
            {
              *base.add(2).cast::<u8>() = (59i32) as u8;
            }
          }
          V3::Sutu=> {
            {
              *base.add(2).cast::<u8>() = (60i32) as u8;
            }
          }
          V3::Swahili=> {
            {
              *base.add(2).cast::<u8>() = (61i32) as u8;
            }
          }
          V3::Swedish=> {
            {
              *base.add(2).cast::<u8>() = (62i32) as u8;
            }
          }
          V3::Tamil=> {
            {
              *base.add(2).cast::<u8>() = (63i32) as u8;
            }
          }
          V3::Tatar=> {
            {
              *base.add(2).cast::<u8>() = (64i32) as u8;
            }
          }
          V3::Telugu=> {
            {
              *base.add(2).cast::<u8>() = (65i32) as u8;
            }
          }
          V3::Thai=> {
            {
              *base.add(2).cast::<u8>() = (66i32) as u8;
            }
          }
          V3::Turkish=> {
            {
              *base.add(2).cast::<u8>() = (67i32) as u8;
            }
          }
          V3::Ukrainian=> {
            {
              *base.add(2).cast::<u8>() = (68i32) as u8;
            }
          }
          V3::Urdu=> {
            {
              *base.add(2).cast::<u8>() = (69i32) as u8;
            }
          }
          V3::Uzbek=> {
            {
              *base.add(2).cast::<u8>() = (70i32) as u8;
            }
          }
          V3::Vietnamese=> {
            {
              *base.add(2).cast::<u8>() = (71i32) as u8;
            }
          }
          V3::Hid=> {
            {
              *base.add(2).cast::<u8>() = (72i32) as u8;
            }
          }
          V3::Other(e) => {
            *base.add(2).cast::<u8>() = (73i32) as u8;
            *base.add(4).cast::<u16>() = (_rt::as_i32(e)) as u16;
          },
        }
        use super::super::super::super::exports::component::usb::types::SubLanguage as V4;
        match sub_language2 {
          V4::Standard=> {
            {
              *base.add(6).cast::<u8>() = (0i32) as u8;
            }
          }
          V4::Classic=> {
            {
              *base.add(6).cast::<u8>() = (1i32) as u8;
            }
          }
          V4::Traditional=> {
            {
              *base.add(6).cast::<u8>() = (2i32) as u8;
            }
          }
          V4::Modern=> {
            {
              *base.add(6).cast::<u8>() = (3i32) as u8;
            }
          }
          V4::Algeria=> {
            {
              *base.add(6).cast::<u8>() = (4i32) as u8;
            }
          }
          V4::Argentina=> {
            {
              *base.add(6).cast::<u8>() = (5i32) as u8;
            }
          }
          V4::Australia=> {
            {
              *base.add(6).cast::<u8>() = (6i32) as u8;
            }
          }
          V4::Austria=> {
            {
              *base.add(6).cast::<u8>() = (7i32) as u8;
            }
          }
          V4::Bahrain=> {
            {
              *base.add(6).cast::<u8>() = (8i32) as u8;
            }
          }
          V4::Belgium=> {
            {
              *base.add(6).cast::<u8>() = (9i32) as u8;
            }
          }
          V4::Belize=> {
            {
              *base.add(6).cast::<u8>() = (10i32) as u8;
            }
          }
          V4::Bokmal=> {
            {
              *base.add(6).cast::<u8>() = (11i32) as u8;
            }
          }
          V4::Bolivia=> {
            {
              *base.add(6).cast::<u8>() = (12i32) as u8;
            }
          }
          V4::Brazil=> {
            {
              *base.add(6).cast::<u8>() = (13i32) as u8;
            }
          }
          V4::BruneiDarussalam=> {
            {
              *base.add(6).cast::<u8>() = (14i32) as u8;
            }
          }
          V4::Canada=> {
            {
              *base.add(6).cast::<u8>() = (15i32) as u8;
            }
          }
          V4::Caribbean=> {
            {
              *base.add(6).cast::<u8>() = (16i32) as u8;
            }
          }
          V4::Chile=> {
            {
              *base.add(6).cast::<u8>() = (17i32) as u8;
            }
          }
          V4::China=> {
            {
              *base.add(6).cast::<u8>() = (18i32) as u8;
            }
          }
          V4::Colombia=> {
            {
              *base.add(6).cast::<u8>() = (19i32) as u8;
            }
          }
          V4::CostaRica=> {
            {
              *base.add(6).cast::<u8>() = (20i32) as u8;
            }
          }
          V4::Cyrillic=> {
            {
              *base.add(6).cast::<u8>() = (21i32) as u8;
            }
          }
          V4::DominicanRepublic=> {
            {
              *base.add(6).cast::<u8>() = (22i32) as u8;
            }
          }
          V4::Ecuador=> {
            {
              *base.add(6).cast::<u8>() = (23i32) as u8;
            }
          }
          V4::Egypt=> {
            {
              *base.add(6).cast::<u8>() = (24i32) as u8;
            }
          }
          V4::ElSalvador=> {
            {
              *base.add(6).cast::<u8>() = (25i32) as u8;
            }
          }
          V4::Finland=> {
            {
              *base.add(6).cast::<u8>() = (26i32) as u8;
            }
          }
          V4::Guatemala=> {
            {
              *base.add(6).cast::<u8>() = (27i32) as u8;
            }
          }
          V4::Honduras=> {
            {
              *base.add(6).cast::<u8>() = (28i32) as u8;
            }
          }
          V4::HongKong=> {
            {
              *base.add(6).cast::<u8>() = (29i32) as u8;
            }
          }
          V4::India=> {
            {
              *base.add(6).cast::<u8>() = (30i32) as u8;
            }
          }
          V4::Iraq=> {
            {
              *base.add(6).cast::<u8>() = (31i32) as u8;
            }
          }
          V4::Ireland=> {
            {
              *base.add(6).cast::<u8>() = (32i32) as u8;
            }
          }
          V4::Jamaica=> {
            {
              *base.add(6).cast::<u8>() = (33i32) as u8;
            }
          }
          V4::Johab=> {
            {
              *base.add(6).cast::<u8>() = (34i32) as u8;
            }
          }
          V4::Jordan=> {
            {
              *base.add(6).cast::<u8>() = (35i32) as u8;
            }
          }
          V4::Kuwait=> {
            {
              *base.add(6).cast::<u8>() = (36i32) as u8;
            }
          }
          V4::Latin=> {
            {
              *base.add(6).cast::<u8>() = (37i32) as u8;
            }
          }
          V4::Lebanon=> {
            {
              *base.add(6).cast::<u8>() = (38i32) as u8;
            }
          }
          V4::Libya=> {
            {
              *base.add(6).cast::<u8>() = (39i32) as u8;
            }
          }
          V4::Liechtenstein=> {
            {
              *base.add(6).cast::<u8>() = (40i32) as u8;
            }
          }
          V4::Luxembourg=> {
            {
              *base.add(6).cast::<u8>() = (41i32) as u8;
            }
          }
          V4::Macau=> {
            {
              *base.add(6).cast::<u8>() = (42i32) as u8;
            }
          }
          V4::Malaysia=> {
            {
              *base.add(6).cast::<u8>() = (43i32) as u8;
            }
          }
          V4::Mexico=> {
            {
              *base.add(6).cast::<u8>() = (44i32) as u8;
            }
          }
          V4::Monaco=> {
            {
              *base.add(6).cast::<u8>() = (45i32) as u8;
            }
          }
          V4::Morocco=> {
            {
              *base.add(6).cast::<u8>() = (46i32) as u8;
            }
          }
          V4::Netherlands=> {
            {
              *base.add(6).cast::<u8>() = (47i32) as u8;
            }
          }
          V4::NewZealand=> {
            {
              *base.add(6).cast::<u8>() = (48i32) as u8;
            }
          }
          V4::Nicaragua=> {
            {
              *base.add(6).cast::<u8>() = (49i32) as u8;
            }
          }
          V4::Nynorsk=> {
            {
              *base.add(6).cast::<u8>() = (50i32) as u8;
            }
          }
          V4::Oman=> {
            {
              *base.add(6).cast::<u8>() = (51i32) as u8;
            }
          }
          V4::Pakistan=> {
            {
              *base.add(6).cast::<u8>() = (52i32) as u8;
            }
          }
          V4::Panama=> {
            {
              *base.add(6).cast::<u8>() = (53i32) as u8;
            }
          }
          V4::Paraguay=> {
            {
              *base.add(6).cast::<u8>() = (54i32) as u8;
            }
          }
          V4::Peru=> {
            {
              *base.add(6).cast::<u8>() = (55i32) as u8;
            }
          }
          V4::Philippines=> {
            {
              *base.add(6).cast::<u8>() = (56i32) as u8;
            }
          }
          V4::PuertoRico=> {
            {
              *base.add(6).cast::<u8>() = (57i32) as u8;
            }
          }
          V4::Qatar=> {
            {
              *base.add(6).cast::<u8>() = (58i32) as u8;
            }
          }
          V4::SaudiArabia=> {
            {
              *base.add(6).cast::<u8>() = (59i32) as u8;
            }
          }
          V4::Singapore=> {
            {
              *base.add(6).cast::<u8>() = (60i32) as u8;
            }
          }
          V4::SouthAfrica=> {
            {
              *base.add(6).cast::<u8>() = (61i32) as u8;
            }
          }
          V4::Switzerland=> {
            {
              *base.add(6).cast::<u8>() = (62i32) as u8;
            }
          }
          V4::Syria=> {
            {
              *base.add(6).cast::<u8>() = (63i32) as u8;
            }
          }
          V4::Taiwan=> {
            {
              *base.add(6).cast::<u8>() = (64i32) as u8;
            }
          }
          V4::Trinidad=> {
            {
              *base.add(6).cast::<u8>() = (65i32) as u8;
            }
          }
          V4::Tunisia=> {
            {
              *base.add(6).cast::<u8>() = (66i32) as u8;
            }
          }
          V4::UnitedArabEmirates=> {
            {
              *base.add(6).cast::<u8>() = (67i32) as u8;
            }
          }
          V4::UnitedKingdom=> {
            {
              *base.add(6).cast::<u8>() = (68i32) as u8;
            }
          }
          V4::UnitedStates=> {
            {
              *base.add(6).cast::<u8>() = (69i32) as u8;
            }
          }
          V4::Uruguay=> {
            {
              *base.add(6).cast::<u8>() = (70i32) as u8;
            }
          }
          V4::Venezuela=> {
            {
              *base.add(6).cast::<u8>() = (71i32) as u8;
            }
          }
          V4::Yemen=> {
            {
              *base.add(6).cast::<u8>() = (72i32) as u8;
            }
          }
          V4::Zimbabwe=> {
            {
              *base.add(6).cast::<u8>() = (73i32) as u8;
            }
          }
          V4::UsageDataDescriptor=> {
            {
              *base.add(6).cast::<u8>() = (74i32) as u8;
            }
          }
          V4::VendorDefined1=> {
            {
              *base.add(6).cast::<u8>() = (75i32) as u8;
            }
          }
          V4::VendorDefined2=> {
            {
              *base.add(6).cast::<u8>() = (76i32) as u8;
            }
          }
          V4::VendorDefined3=> {
            {
              *base.add(6).cast::<u8>() = (77i32) as u8;
            }
          }
          V4::VendorDefined4=> {
            {
              *base.add(6).cast::<u8>() = (78i32) as u8;
            }
          }
          V4::Other(e) => {
            *base.add(6).cast::<u8>() = (79i32) as u8;
            *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
          },
        }
      }
    }
    *ptr1.add(8).cast::<usize>() = len5;
    *ptr1.add(4).cast::<*mut u8>() = result5;
  } },
  Err(_) => { {
    *ptr1.add(0).cast::<u8>() = (1i32) as u8;
  } },
};ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_method_device_handle_read_languages<T: GuestDeviceHandle>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => {
      let l1 = *arg0.add(4).cast::<*mut u8>();
      let l2 = *arg0.add(8).cast::<usize>();
      let base3 = l1;
      let len3 = l2;
      _rt::cabi_dealloc(base3, len3 * 10, 2);
    },
    _ => (),
  }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_read_string_descriptor_ascii_cabi<T: GuestDeviceHandle>(arg0: *mut u8,arg1: i32,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::read_string_descriptor_ascii(DeviceHandleBorrow::lift(arg0 as u32 as usize).get(), arg1 as u8);
let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result0 {
  Ok(e) => { {
    *ptr1.add(0).cast::<u8>() = (0i32) as u8;
    let vec2 = (e.into_bytes()).into_boxed_slice();
    let ptr2 = vec2.as_ptr().cast::<u8>();
    let len2 = vec2.len();
    ::core::mem::forget(vec2);
    *ptr1.add(8).cast::<usize>() = len2;
    *ptr1.add(4).cast::<*mut u8>() = ptr2.cast_mut();
  } },
  Err(_) => { {
    *ptr1.add(0).cast::<u8>() = (1i32) as u8;
  } },
};ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_method_device_handle_read_string_descriptor_ascii<T: GuestDeviceHandle>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => {
      let l1 = *arg0.add(4).cast::<*mut u8>();
      let l2 = *arg0.add(8).cast::<usize>();
      _rt::cabi_dealloc(l1, l2, 1);
    },
    _ => (),
  }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_read_string_descriptor_cabi<T: GuestDeviceHandle>(arg0: *mut u8,arg1: i32,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i64,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();use super::super::super::super::exports::component::usb::types::PrimaryLanguage as V0;
let v0 = match arg2 {
  0 => {
    V0::Afrikaans
  }
  1 => {
    V0::Albanian
  }
  2 => {
    V0::Arabic
  }
  3 => {
    V0::Armenian
  }
  4 => {
    V0::Assamese
  }
  5 => {
    V0::Azeri
  }
  6 => {
    V0::Basque
  }
  7 => {
    V0::Belarussian
  }
  8 => {
    V0::Bengali
  }
  9 => {
    V0::Bulgarian
  }
  10 => {
    V0::Burmese
  }
  11 => {
    V0::Catalan
  }
  12 => {
    V0::Chinese
  }
  13 => {
    V0::Croatian
  }
  14 => {
    V0::Czech
  }
  15 => {
    V0::Danish
  }
  16 => {
    V0::Dutch
  }
  17 => {
    V0::English
  }
  18 => {
    V0::Estonian
  }
  19 => {
    V0::Faeroese
  }
  20 => {
    V0::Farsi
  }
  21 => {
    V0::Finnish
  }
  22 => {
    V0::French
  }
  23 => {
    V0::Georgian
  }
  24 => {
    V0::German
  }
  25 => {
    V0::Greek
  }
  26 => {
    V0::Gujarati
  }
  27 => {
    V0::Hebrew
  }
  28 => {
    V0::Hindi
  }
  29 => {
    V0::Hungarian
  }
  30 => {
    V0::Icelandic
  }
  31 => {
    V0::Indonesian
  }
  32 => {
    V0::Italian
  }
  33 => {
    V0::Japanese
  }
  34 => {
    V0::Kannada
  }
  35 => {
    V0::Kashmiri
  }
  36 => {
    V0::Kazakh
  }
  37 => {
    V0::Konkani
  }
  38 => {
    V0::Korean
  }
  39 => {
    V0::Latvian
  }
  40 => {
    V0::Lithuanian
  }
  41 => {
    V0::Macedonian
  }
  42 => {
    V0::Malay
  }
  43 => {
    V0::Malayalam
  }
  44 => {
    V0::Manipuri
  }
  45 => {
    V0::Marathi
  }
  46 => {
    V0::Nepali
  }
  47 => {
    V0::Norwegian
  }
  48 => {
    V0::Oriya
  }
  49 => {
    V0::Polish
  }
  50 => {
    V0::Portuguese
  }
  51 => {
    V0::Punjabi
  }
  52 => {
    V0::Romanian
  }
  53 => {
    V0::Russian
  }
  54 => {
    V0::Sanskrit
  }
  55 => {
    V0::Serbian
  }
  56 => {
    V0::Sindhi
  }
  57 => {
    V0::Slovak
  }
  58 => {
    V0::Slovenian
  }
  59 => {
    V0::Spanish
  }
  60 => {
    V0::Sutu
  }
  61 => {
    V0::Swahili
  }
  62 => {
    V0::Swedish
  }
  63 => {
    V0::Tamil
  }
  64 => {
    V0::Tatar
  }
  65 => {
    V0::Telugu
  }
  66 => {
    V0::Thai
  }
  67 => {
    V0::Turkish
  }
  68 => {
    V0::Ukrainian
  }
  69 => {
    V0::Urdu
  }
  70 => {
    V0::Uzbek
  }
  71 => {
    V0::Vietnamese
  }
  72 => {
    V0::Hid
  }
  n => {
    debug_assert_eq!(n, 73, "invalid enum discriminant");
    let e0 = arg3 as u16;
    V0::Other(e0)
  }
};
use super::super::super::super::exports::component::usb::types::SubLanguage as V1;
let v1 = match arg4 {
  0 => {
    V1::Standard
  }
  1 => {
    V1::Classic
  }
  2 => {
    V1::Traditional
  }
  3 => {
    V1::Modern
  }
  4 => {
    V1::Algeria
  }
  5 => {
    V1::Argentina
  }
  6 => {
    V1::Australia
  }
  7 => {
    V1::Austria
  }
  8 => {
    V1::Bahrain
  }
  9 => {
    V1::Belgium
  }
  10 => {
    V1::Belize
  }
  11 => {
    V1::Bokmal
  }
  12 => {
    V1::Bolivia
  }
  13 => {
    V1::Brazil
  }
  14 => {
    V1::BruneiDarussalam
  }
  15 => {
    V1::Canada
  }
  16 => {
    V1::Caribbean
  }
  17 => {
    V1::Chile
  }
  18 => {
    V1::China
  }
  19 => {
    V1::Colombia
  }
  20 => {
    V1::CostaRica
  }
  21 => {
    V1::Cyrillic
  }
  22 => {
    V1::DominicanRepublic
  }
  23 => {
    V1::Ecuador
  }
  24 => {
    V1::Egypt
  }
  25 => {
    V1::ElSalvador
  }
  26 => {
    V1::Finland
  }
  27 => {
    V1::Guatemala
  }
  28 => {
    V1::Honduras
  }
  29 => {
    V1::HongKong
  }
  30 => {
    V1::India
  }
  31 => {
    V1::Iraq
  }
  32 => {
    V1::Ireland
  }
  33 => {
    V1::Jamaica
  }
  34 => {
    V1::Johab
  }
  35 => {
    V1::Jordan
  }
  36 => {
    V1::Kuwait
  }
  37 => {
    V1::Latin
  }
  38 => {
    V1::Lebanon
  }
  39 => {
    V1::Libya
  }
  40 => {
    V1::Liechtenstein
  }
  41 => {
    V1::Luxembourg
  }
  42 => {
    V1::Macau
  }
  43 => {
    V1::Malaysia
  }
  44 => {
    V1::Mexico
  }
  45 => {
    V1::Monaco
  }
  46 => {
    V1::Morocco
  }
  47 => {
    V1::Netherlands
  }
  48 => {
    V1::NewZealand
  }
  49 => {
    V1::Nicaragua
  }
  50 => {
    V1::Nynorsk
  }
  51 => {
    V1::Oman
  }
  52 => {
    V1::Pakistan
  }
  53 => {
    V1::Panama
  }
  54 => {
    V1::Paraguay
  }
  55 => {
    V1::Peru
  }
  56 => {
    V1::Philippines
  }
  57 => {
    V1::PuertoRico
  }
  58 => {
    V1::Qatar
  }
  59 => {
    V1::SaudiArabia
  }
  60 => {
    V1::Singapore
  }
  61 => {
    V1::SouthAfrica
  }
  62 => {
    V1::Switzerland
  }
  63 => {
    V1::Syria
  }
  64 => {
    V1::Taiwan
  }
  65 => {
    V1::Trinidad
  }
  66 => {
    V1::Tunisia
  }
  67 => {
    V1::UnitedArabEmirates
  }
  68 => {
    V1::UnitedKingdom
  }
  69 => {
    V1::UnitedStates
  }
  70 => {
    V1::Uruguay
  }
  71 => {
    V1::Venezuela
  }
  72 => {
    V1::Yemen
  }
  73 => {
    V1::Zimbabwe
  }
  74 => {
    V1::UsageDataDescriptor
  }
  75 => {
    V1::VendorDefined1
  }
  76 => {
    V1::VendorDefined2
  }
  77 => {
    V1::VendorDefined3
  }
  78 => {
    V1::VendorDefined4
  }
  n => {
    debug_assert_eq!(n, 79, "invalid enum discriminant");
    let e1 = arg5 as u16;
    V1::Other(e1)
  }
};
let result2 = T::read_string_descriptor(DeviceHandleBorrow::lift(arg0 as u32 as usize).get(), super::super::super::super::exports::component::usb::types::Language{
  id: arg1 as u16,
  primary_language: v0,
  sub_language: v1,
}, arg6 as u8, arg7 as u64);
let ptr3 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result2 {
  Ok(e) => { {
    *ptr3.add(0).cast::<u8>() = (0i32) as u8;
    let vec4 = (e.into_bytes()).into_boxed_slice();
    let ptr4 = vec4.as_ptr().cast::<u8>();
    let len4 = vec4.len();
    ::core::mem::forget(vec4);
    *ptr3.add(8).cast::<usize>() = len4;
    *ptr3.add(4).cast::<*mut u8>() = ptr4.cast_mut();
  } },
  Err(_) => { {
    *ptr3.add(0).cast::<u8>() = (1i32) as u8;
  } },
};ptr3
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_method_device_handle_read_string_descriptor<T: GuestDeviceHandle>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => {
      let l1 = *arg0.add(4).cast::<*mut u8>();
      let l2 = *arg0.add(8).cast::<usize>();
      _rt::cabi_dealloc(l1, l2, 1);
    },
    _ => (),
  }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_method_device_handle_read_manufacturer_string_ascii_cabi<T: GuestDeviceHandle>(arg0: *mut u8,) {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let l0 = *arg0.add(0).cast::<i32>();
let l1 = i32::from(*arg0.add(4).cast::<u8>());
let l2 = i32::from(*arg0.add(5).cast::<u8>());
let l3 = i32::from(*arg0.add(6).cast::<u8>());
let l4 = i32::from(*arg0.add(7).cast::<u8>());
let l5 = i32::from(*arg0.add(8).cast::<u8>());
let l6 = i32::from(*arg0.add(9).cast::<u8>());
let l7 = i32::from(*arg0.add(10).cast::<u8>());
let l9 = i32::from(*arg0.add(12).cast::<u8>());
let l11 = i32::from(*arg0.add(14).cast::<u8>());
let l13 = i32::from(*arg0.add(16).cast::<u8>());
let l14 = i32::from(*arg0.add(17).cast::<u8>());
let l15 = i32::from(*arg0.add(18).cast::<u8>());
let l16 = i32::from(*arg0.add(20).cast::<u16>());
let l17 = i32::from(*arg0.add(22).cast::<u16>());
let l18 = i32::from(*arg0.add(24).cast::<u8>());
let l19 = i32::from(*arg0.add(25).cast::<u8>());
T::read_manufacturer_string_ascii(DeviceHandleBorrow::lift(l0 as u32 as usize).get(), super::super::super::super::exports::component::usb::descriptors::DeviceDescriptor{
  usb_version: super::super::super::super::exports::component::usb::types::Version{
    major: l1 as u8,
    minor: l2 as u8,
    subminor: l3 as u8,
  },
  device_version: super::super::super::super::exports::component::usb::types::Version{
    major: l4 as u8,
    minor: l5 as u8,
    subminor: l6 as u8,
  },
  manufacturer_string: match l7 {
    0 => None,
    1 => {
      let e = {
        let l8 = i32::from(*arg0.add(11).cast::<u8>());

        l8 as u8
      };
      Some(e)
    }
    _ => _rt::invalid_enum_discriminant(),
  },
  product_string: match l9 {
    0 => None,
    1 => {
      let e = {
        let l10 = i32::from(*arg0.add(13).cast::<u8>());

        l10 as u8
      };
      Some(e)
    }
    _ => _rt::invalid_enum_discriminant(),
  },
  serial_number_string: match l11 {
    0 => None,
    1 => {
      let e = {
        let l12 = i32::from(*arg0.add(15).cast::<u8>());

        l12 as u8
      };
      Some(e)
    }
    _ => _rt::invalid_enum_discriminant(),
  },
  class_code: l13 as u8,
  subclass_code: l14 as u8,
  protocol_code: l15 as u8,
  vendor_id: l16 as u16,
  product_id: l17 as u16,
  max_packet_size: l18 as u8,
  num_configurations: l19 as u8,
});
_rt::cabi_dealloc(arg0, 28, 4);
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_get_context_cabi<T: Guest>() -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::get_context();
let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result0 {
  Ok(e) => { {
    *ptr1.add(0).cast::<u8>() = (0i32) as u8;
    *ptr1.add(4).cast::<i32>() = (e).take_handle() as i32;
  } },
  Err(_) => { {
    *ptr1.add(0).cast::<u8>() = (1i32) as u8;
  } },
};ptr1
}
pub trait Guest {
  type UsbDevice: GuestUsbDevice;
  type Context: GuestContext;
  type DeviceHandle: GuestDeviceHandle;
  fn get_context() -> Result<Context,()>;
}
pub trait GuestUsbDevice: 'static {

  #[doc(hidden)]
  unsafe fn _resource_new(val: *mut u8) -> u32
  where Self: Sized
  {
    #[cfg(not(target_arch = "wasm32"))]
    {
      let _ = val;
      unreachable!();
    }

    #[cfg(target_arch = "wasm32")]
    {
      #[link(wasm_import_module = "[export]component:usb/usb@0.2.1")]
      extern "C" {
        #[link_name = "[resource-new]usb-device"]
        fn new(_: *mut u8) -> u32;
      }
      new(val)
    }
  }

  #[doc(hidden)]
  fn _resource_rep(handle: u32) -> *mut u8
  where Self: Sized
  {
    #[cfg(not(target_arch = "wasm32"))]
    {
      let _ = handle;
      unreachable!();
    }

    #[cfg(target_arch = "wasm32")]
    {
      #[link(wasm_import_module = "[export]component:usb/usb@0.2.1")]
      extern "C" {
        #[link_name = "[resource-rep]usb-device"]
        fn rep(_: u32) -> *mut u8;
      }
      unsafe {
        rep(handle)
      }
    }
  }

  
  fn device_descriptor(&self,) -> Result<DeviceDescriptor,()>;
  fn config_descriptor(&self,) -> Result<ConfigDescriptor,()>;
  fn bus_number(&self,) -> u8;
  fn address(&self,) -> u8;
  fn speed(&self,) -> Speed;
  fn open(&self,) -> Result<DeviceHandle,()>;
  fn port_number(&self,) -> u8;
}
pub trait GuestContext: 'static {

  #[doc(hidden)]
  unsafe fn _resource_new(val: *mut u8) -> u32
  where Self: Sized
  {
    #[cfg(not(target_arch = "wasm32"))]
    {
      let _ = val;
      unreachable!();
    }

    #[cfg(target_arch = "wasm32")]
    {
      #[link(wasm_import_module = "[export]component:usb/usb@0.2.1")]
      extern "C" {
        #[link_name = "[resource-new]context"]
        fn new(_: *mut u8) -> u32;
      }
      new(val)
    }
  }

  #[doc(hidden)]
  fn _resource_rep(handle: u32) -> *mut u8
  where Self: Sized
  {
    #[cfg(not(target_arch = "wasm32"))]
    {
      let _ = handle;
      unreachable!();
    }

    #[cfg(target_arch = "wasm32")]
    {
      #[link(wasm_import_module = "[export]component:usb/usb@0.2.1")]
      extern "C" {
        #[link_name = "[resource-rep]context"]
        fn rep(_: u32) -> *mut u8;
      }
      unsafe {
        rep(handle)
      }
    }
  }

  
  fn devices(&self,) -> Result<_rt::Vec::<UsbDevice>,()>;
  fn open_device_with_vid_pid(&self,vendor_id: u16,product_id: u16,) -> Option<DeviceHandle>;
}
pub trait GuestDeviceHandle: 'static {

  #[doc(hidden)]
  unsafe fn _resource_new(val: *mut u8) -> u32
  where Self: Sized
  {
    #[cfg(not(target_arch = "wasm32"))]
    {
      let _ = val;
      unreachable!();
    }

    #[cfg(target_arch = "wasm32")]
    {
      #[link(wasm_import_module = "[export]component:usb/usb@0.2.1")]
      extern "C" {
        #[link_name = "[resource-new]device-handle"]
        fn new(_: *mut u8) -> u32;
      }
      new(val)
    }
  }

  #[doc(hidden)]
  fn _resource_rep(handle: u32) -> *mut u8
  where Self: Sized
  {
    #[cfg(not(target_arch = "wasm32"))]
    {
      let _ = handle;
      unreachable!();
    }

    #[cfg(target_arch = "wasm32")]
    {
      #[link(wasm_import_module = "[export]component:usb/usb@0.2.1")]
      extern "C" {
        #[link_name = "[resource-rep]device-handle"]
        fn rep(_: u32) -> *mut u8;
      }
      unsafe {
        rep(handle)
      }
    }
  }

  
  fn device(&self,) -> UsbDevice;
  fn active_configuration(&self,) -> Result<u8,()>;
  fn set_active_configuration(&self,config: u8,) -> Result<(),()>;
  fn unconfigure(&self,) -> Result<(),()>;
  fn reset(&self,) -> Result<(),()>;
  fn clear_halt(&self,endpoint: u8,) -> Result<(),()>;
  fn kernel_driver_active(&self,) -> Result<bool,()>;
  fn detach_kernel_driver(&self,) -> Result<(),()>;
  fn attach_kernel_driver(&self,) -> Result<(),()>;
  fn set_auto_attach_detach_kernel_driver(&self,auto: bool,) -> Result<(),()>;
  fn claim_interface(&self,iface: u8,) -> Result<(),()>;
  fn release_interface(&self,iface: u8,) -> Result<(),()>;
  fn set_interface_alt_setting(&self,iface: u8,alt_setting: u8,) -> Result<(),()>;
  fn read_interrupt(&self,endpoint: u8,timeout: Duration,) -> Result<(u64,_rt::Vec::<u8>,),DeviceHandleError>;
  fn write_interrupt(&self,endpoint: u8,data: _rt::Vec::<u8>,timeout: Duration,) -> Result<u64,DeviceHandleError>;
  fn read_bulk(&self,endpoint: u8,max_size: u64,timeout: Duration,) -> Result<(u64,_rt::Vec::<u8>,),DeviceHandleError>;
  fn write_bulk(&self,endpoint: u8,data: _rt::Vec::<u8>,timeout: Duration,) -> Result<u64,DeviceHandleError>;
  fn read_control(&self,request_type: u8,request: u8,value: u16,index: u16,max_size: u16,timeout: Duration,) -> Result<(u64,_rt::Vec::<u8>,),DeviceHandleError>;
  fn write_control(&self,request_type: u8,request: u8,value: u16,index: u16,data: _rt::Vec::<u8>,timeout: Duration,) -> Result<u64,DeviceHandleError>;
  fn read_languages(&self,timeout: Duration,) -> Result<_rt::Vec::<Language>,()>;
  fn read_string_descriptor_ascii(&self,index: u8,) -> Result<_rt::String,()>;
  fn read_string_descriptor(&self,language: Language,index: u8,timeout: Duration,) -> Result<_rt::String,()>;
  fn read_manufacturer_string_ascii(&self,device: DeviceDescriptor,);
}
#[doc(hidden)]

macro_rules! __export_component_usb_usb_0_2_1_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "component:usb/usb@0.2.1#[method]usb-device.device-descriptor"]
    unsafe extern "C" fn export_method_usb_device_device_descriptor(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_usb_device_device_descriptor_cabi::<<$ty as $($path_to_types)*::Guest>::UsbDevice>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]usb-device.config-descriptor"]
    unsafe extern "C" fn export_method_usb_device_config_descriptor(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_usb_device_config_descriptor_cabi::<<$ty as $($path_to_types)*::Guest>::UsbDevice>(arg0)
    }
    #[export_name = "cabi_post_component:usb/usb@0.2.1#[method]usb-device.config-descriptor"]
    unsafe extern "C" fn _post_return_method_usb_device_config_descriptor(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_method_usb_device_config_descriptor::<<$ty as $($path_to_types)*::Guest>::UsbDevice>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]usb-device.bus-number"]
    unsafe extern "C" fn export_method_usb_device_bus_number(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_usb_device_bus_number_cabi::<<$ty as $($path_to_types)*::Guest>::UsbDevice>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]usb-device.address"]
    unsafe extern "C" fn export_method_usb_device_address(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_usb_device_address_cabi::<<$ty as $($path_to_types)*::Guest>::UsbDevice>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]usb-device.speed"]
    unsafe extern "C" fn export_method_usb_device_speed(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_usb_device_speed_cabi::<<$ty as $($path_to_types)*::Guest>::UsbDevice>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]usb-device.open"]
    unsafe extern "C" fn export_method_usb_device_open(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_usb_device_open_cabi::<<$ty as $($path_to_types)*::Guest>::UsbDevice>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]usb-device.port-number"]
    unsafe extern "C" fn export_method_usb_device_port_number(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_usb_device_port_number_cabi::<<$ty as $($path_to_types)*::Guest>::UsbDevice>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]context.devices"]
    unsafe extern "C" fn export_method_context_devices(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_context_devices_cabi::<<$ty as $($path_to_types)*::Guest>::Context>(arg0)
    }
    #[export_name = "cabi_post_component:usb/usb@0.2.1#[method]context.devices"]
    unsafe extern "C" fn _post_return_method_context_devices(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_method_context_devices::<<$ty as $($path_to_types)*::Guest>::Context>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]context.open-device-with-vid-pid"]
    unsafe extern "C" fn export_method_context_open_device_with_vid_pid(arg0: *mut u8,arg1: i32,arg2: i32,) -> *mut u8 {
      $($path_to_types)*::_export_method_context_open_device_with_vid_pid_cabi::<<$ty as $($path_to_types)*::Guest>::Context>(arg0, arg1, arg2)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.device"]
    unsafe extern "C" fn export_method_device_handle_device(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_device_handle_device_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.active-configuration"]
    unsafe extern "C" fn export_method_device_handle_active_configuration(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_device_handle_active_configuration_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.set-active-configuration"]
    unsafe extern "C" fn export_method_device_handle_set_active_configuration(arg0: *mut u8,arg1: i32,) -> i32 {
      $($path_to_types)*::_export_method_device_handle_set_active_configuration_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0, arg1)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.unconfigure"]
    unsafe extern "C" fn export_method_device_handle_unconfigure(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_device_handle_unconfigure_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.reset"]
    unsafe extern "C" fn export_method_device_handle_reset(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_device_handle_reset_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.clear-halt"]
    unsafe extern "C" fn export_method_device_handle_clear_halt(arg0: *mut u8,arg1: i32,) -> i32 {
      $($path_to_types)*::_export_method_device_handle_clear_halt_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0, arg1)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.kernel-driver-active"]
    unsafe extern "C" fn export_method_device_handle_kernel_driver_active(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_device_handle_kernel_driver_active_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.detach-kernel-driver"]
    unsafe extern "C" fn export_method_device_handle_detach_kernel_driver(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_device_handle_detach_kernel_driver_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.attach-kernel-driver"]
    unsafe extern "C" fn export_method_device_handle_attach_kernel_driver(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_device_handle_attach_kernel_driver_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.set-auto-attach-detach-kernel-driver"]
    unsafe extern "C" fn export_method_device_handle_set_auto_attach_detach_kernel_driver(arg0: *mut u8,arg1: i32,) -> i32 {
      $($path_to_types)*::_export_method_device_handle_set_auto_attach_detach_kernel_driver_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0, arg1)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.claim-interface"]
    unsafe extern "C" fn export_method_device_handle_claim_interface(arg0: *mut u8,arg1: i32,) -> i32 {
      $($path_to_types)*::_export_method_device_handle_claim_interface_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0, arg1)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.release-interface"]
    unsafe extern "C" fn export_method_device_handle_release_interface(arg0: *mut u8,arg1: i32,) -> i32 {
      $($path_to_types)*::_export_method_device_handle_release_interface_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0, arg1)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.set-interface-alt-setting"]
    unsafe extern "C" fn export_method_device_handle_set_interface_alt_setting(arg0: *mut u8,arg1: i32,arg2: i32,) -> i32 {
      $($path_to_types)*::_export_method_device_handle_set_interface_alt_setting_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0, arg1, arg2)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.read-interrupt"]
    unsafe extern "C" fn export_method_device_handle_read_interrupt(arg0: *mut u8,arg1: i32,arg2: i64,) -> *mut u8 {
      $($path_to_types)*::_export_method_device_handle_read_interrupt_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0, arg1, arg2)
    }
    #[export_name = "cabi_post_component:usb/usb@0.2.1#[method]device-handle.read-interrupt"]
    unsafe extern "C" fn _post_return_method_device_handle_read_interrupt(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_method_device_handle_read_interrupt::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.write-interrupt"]
    unsafe extern "C" fn export_method_device_handle_write_interrupt(arg0: *mut u8,arg1: i32,arg2: *mut u8,arg3: usize,arg4: i64,) -> *mut u8 {
      $($path_to_types)*::_export_method_device_handle_write_interrupt_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0, arg1, arg2, arg3, arg4)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.read-bulk"]
    unsafe extern "C" fn export_method_device_handle_read_bulk(arg0: *mut u8,arg1: i32,arg2: i64,arg3: i64,) -> *mut u8 {
      $($path_to_types)*::_export_method_device_handle_read_bulk_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0, arg1, arg2, arg3)
    }
    #[export_name = "cabi_post_component:usb/usb@0.2.1#[method]device-handle.read-bulk"]
    unsafe extern "C" fn _post_return_method_device_handle_read_bulk(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_method_device_handle_read_bulk::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.write-bulk"]
    unsafe extern "C" fn export_method_device_handle_write_bulk(arg0: *mut u8,arg1: i32,arg2: *mut u8,arg3: usize,arg4: i64,) -> *mut u8 {
      $($path_to_types)*::_export_method_device_handle_write_bulk_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0, arg1, arg2, arg3, arg4)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.read-control"]
    unsafe extern "C" fn export_method_device_handle_read_control(arg0: *mut u8,arg1: i32,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i64,) -> *mut u8 {
      $($path_to_types)*::_export_method_device_handle_read_control_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
    #[export_name = "cabi_post_component:usb/usb@0.2.1#[method]device-handle.read-control"]
    unsafe extern "C" fn _post_return_method_device_handle_read_control(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_method_device_handle_read_control::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.write-control"]
    unsafe extern "C" fn export_method_device_handle_write_control(arg0: *mut u8,arg1: i32,arg2: i32,arg3: i32,arg4: i32,arg5: *mut u8,arg6: usize,arg7: i64,) -> *mut u8 {
      $($path_to_types)*::_export_method_device_handle_write_control_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.read-languages"]
    unsafe extern "C" fn export_method_device_handle_read_languages(arg0: *mut u8,arg1: i64,) -> *mut u8 {
      $($path_to_types)*::_export_method_device_handle_read_languages_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0, arg1)
    }
    #[export_name = "cabi_post_component:usb/usb@0.2.1#[method]device-handle.read-languages"]
    unsafe extern "C" fn _post_return_method_device_handle_read_languages(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_method_device_handle_read_languages::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.read-string-descriptor-ascii"]
    unsafe extern "C" fn export_method_device_handle_read_string_descriptor_ascii(arg0: *mut u8,arg1: i32,) -> *mut u8 {
      $($path_to_types)*::_export_method_device_handle_read_string_descriptor_ascii_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0, arg1)
    }
    #[export_name = "cabi_post_component:usb/usb@0.2.1#[method]device-handle.read-string-descriptor-ascii"]
    unsafe extern "C" fn _post_return_method_device_handle_read_string_descriptor_ascii(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_method_device_handle_read_string_descriptor_ascii::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.read-string-descriptor"]
    unsafe extern "C" fn export_method_device_handle_read_string_descriptor(arg0: *mut u8,arg1: i32,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i64,) -> *mut u8 {
      $($path_to_types)*::_export_method_device_handle_read_string_descriptor_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    }
    #[export_name = "cabi_post_component:usb/usb@0.2.1#[method]device-handle.read-string-descriptor"]
    unsafe extern "C" fn _post_return_method_device_handle_read_string_descriptor(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_method_device_handle_read_string_descriptor::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#[method]device-handle.read-manufacturer-string-ascii"]
    unsafe extern "C" fn export_method_device_handle_read_manufacturer_string_ascii(arg0: *mut u8,) {
      $($path_to_types)*::_export_method_device_handle_read_manufacturer_string_ascii_cabi::<<$ty as $($path_to_types)*::Guest>::DeviceHandle>(arg0)
    }
    #[export_name = "component:usb/usb@0.2.1#get-context"]
    unsafe extern "C" fn export_get_context() -> *mut u8 {
      $($path_to_types)*::_export_get_context_cabi::<$ty>()
    }

    const _: () = {
      #[doc(hidden)]
      #[export_name = "component:usb/usb@0.2.1#[dtor]usb-device"]
      #[allow(non_snake_case)]
      unsafe extern "C" fn dtor(rep: *mut u8) {
        $($path_to_types)*::UsbDevice::dtor::<
        <$ty as $($path_to_types)*::Guest>::UsbDevice
        >(rep)
      }
    };
    

    const _: () = {
      #[doc(hidden)]
      #[export_name = "component:usb/usb@0.2.1#[dtor]context"]
      #[allow(non_snake_case)]
      unsafe extern "C" fn dtor(rep: *mut u8) {
        $($path_to_types)*::Context::dtor::<
        <$ty as $($path_to_types)*::Guest>::Context
        >(rep)
      }
    };
    

    const _: () = {
      #[doc(hidden)]
      #[export_name = "component:usb/usb@0.2.1#[dtor]device-handle"]
      #[allow(non_snake_case)]
      unsafe extern "C" fn dtor(rep: *mut u8) {
        $($path_to_types)*::DeviceHandle::dtor::<
        <$ty as $($path_to_types)*::Guest>::DeviceHandle
        >(rep)
      }
    };
    
  };);
}
#[doc(hidden)]
pub(crate) use __export_component_usb_usb_0_2_1_cabi;
#[repr(align(8))]
struct _RetArea([::core::mem::MaybeUninit::<u8>; 24]);
static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 24]);

}

#[allow(dead_code, clippy::all)]
pub mod events {
  #[used]
  #[doc(hidden)]
  #[cfg(target_arch = "wasm32")]
  static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
  use super::super::super::super::_rt;
  pub type UsbDevice = super::super::super::super::exports::component::usb::usb::UsbDevice;
  pub type UsbDeviceBorrow<'a> = super::super::super::super::exports::component::usb::usb::UsbDeviceBorrow<'a>;
  pub enum DeviceConnectionEvent {
    Pending,
    Connected(UsbDevice),
    Disconnected(UsbDevice),
  }
  impl ::core::fmt::Debug for DeviceConnectionEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      match self {
        DeviceConnectionEvent::Pending => {
          f.debug_tuple("DeviceConnectionEvent::Pending").finish()
        }
        DeviceConnectionEvent::Connected(e) => {
          f.debug_tuple("DeviceConnectionEvent::Connected").field(e).finish()
        }
        DeviceConnectionEvent::Disconnected(e) => {
          f.debug_tuple("DeviceConnectionEvent::Disconnected").field(e).finish()
        }
      }
    }
  }
  #[doc(hidden)]
  #[allow(non_snake_case)]
  pub unsafe fn _export_update_cabi<T: Guest>() -> *mut u8 {#[cfg(target_arch="wasm32")]
  _rt::run_ctors_once();let result0 = T::update();
  let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
  match result0 {
    DeviceConnectionEvent::Pending=> {
      {
        *ptr1.add(0).cast::<u8>() = (0i32) as u8;
      }
    }
    DeviceConnectionEvent::Connected(e) => {
      *ptr1.add(0).cast::<u8>() = (1i32) as u8;
      *ptr1.add(4).cast::<i32>() = (e).take_handle() as i32;
    },
    DeviceConnectionEvent::Disconnected(e) => {
      *ptr1.add(0).cast::<u8>() = (2i32) as u8;
      *ptr1.add(4).cast::<i32>() = (e).take_handle() as i32;
    },
  }
  ptr1
}
pub trait Guest {
  /// TODO: wasip3 will support async functions and streams
  fn update() -> DeviceConnectionEvent;
}
#[doc(hidden)]

macro_rules! __export_component_usb_events_0_2_1_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "component:usb/events@0.2.1#update"]
    unsafe extern "C" fn export_update() -> *mut u8 {
      $($path_to_types)*::_export_update_cabi::<$ty>()
    }
  };);
}
#[doc(hidden)]
pub(crate) use __export_component_usb_events_0_2_1_cabi;
#[repr(align(4))]
struct _RetArea([::core::mem::MaybeUninit::<u8>; 8]);
static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 8]);

}

}
}
}
mod _rt {
  pub use alloc_crate::vec::Vec;


  use core::fmt;
  use core::marker;
  use core::sync::atomic::{AtomicU32, Ordering::Relaxed};

  /// A type which represents a component model resource, either imported or
  /// exported into this component.
  ///
  /// This is a low-level wrapper which handles the lifetime of the resource
  /// (namely this has a destructor). The `T` provided defines the component model
  /// intrinsics that this wrapper uses.
  ///
  /// One of the chief purposes of this type is to provide `Deref` implementations
  /// to access the underlying data when it is owned.
  ///
  /// This type is primarily used in generated code for exported and imported
  /// resources.
  #[repr(transparent)]
  pub struct Resource<T: WasmResource> {
    // NB: This would ideally be `u32` but it is not. The fact that this has
    // interior mutability is not exposed in the API of this type except for the
    // `take_handle` method which is supposed to in theory be private.
    //
    // This represents, almost all the time, a valid handle value. When it's
    // invalid it's stored as `u32::MAX`.
    handle: AtomicU32,
    _marker: marker::PhantomData<T>,
  }

  /// A trait which all wasm resources implement, namely providing the ability to
  /// drop a resource.
  ///
  /// This generally is implemented by generated code, not user-facing code.
  pub unsafe trait WasmResource {
    /// Invokes the `[resource-drop]...` intrinsic.
    unsafe fn drop(handle: u32);
  }

  impl<T: WasmResource> Resource<T> {
    #[doc(hidden)]
    pub unsafe fn from_handle(handle: u32) -> Self {
      debug_assert!(handle != u32::MAX);
      Self {
        handle: AtomicU32::new(handle),
        _marker: marker::PhantomData,
      }
    }

    /// Takes ownership of the handle owned by `resource`.
    ///
    /// Note that this ideally would be `into_handle` taking `Resource<T>` by
    /// ownership. The code generator does not enable that in all situations,
    /// unfortunately, so this is provided instead.
    ///
    /// Also note that `take_handle` is in theory only ever called on values
    /// owned by a generated function. For example a generated function might
    /// take `Resource<T>` as an argument but then call `take_handle` on a
    /// reference to that argument. In that sense the dynamic nature of
    /// `take_handle` should only be exposed internally to generated code, not
    /// to user code.
    #[doc(hidden)]
    pub fn take_handle(resource: &Resource<T>) -> u32 {
      resource.handle.swap(u32::MAX, Relaxed)
    }

    #[doc(hidden)]
    pub fn handle(resource: &Resource<T>) -> u32 {
      resource.handle.load(Relaxed)
    }
  }

  impl<T: WasmResource> fmt::Debug for Resource<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
      f.debug_struct("Resource")
      .field("handle", &self.handle)
      .finish()
    }
  }

  impl<T: WasmResource> Drop for Resource<T> {
    fn drop(&mut self) {
      unsafe {
        match self.handle.load(Relaxed) {
          // If this handle was "taken" then don't do anything in the
          // destructor.
          u32::MAX => {}

          // ... but otherwise do actually destroy it with the imported
          // component model intrinsic as defined through `T`.
          other => T::drop(other),
        }
      }
    }
  }
  pub unsafe fn invalid_enum_discriminant<T>() -> T {
    if cfg!(debug_assertions) {
      panic!("invalid enum discriminant")
    } else {
      core::hint::unreachable_unchecked()
    }
  }
  pub unsafe fn bool_lift(val: u8) -> bool {
    if cfg!(debug_assertions) {
      match val {
        0 => false,
        1 => true,
        _ => panic!("invalid bool discriminant"),
      }
    } else {
      val != 0
    }
  }
  pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
    if size == 0 {
      return;
    }
    let layout = alloc::Layout::from_size_align_unchecked(size, align);
    alloc::dealloc(ptr as *mut u8, layout);
  }
  
  pub fn as_i32<T: AsI32>(t: T) -> i32 {
    t.as_i32()
  }

  pub trait AsI32 {
    fn as_i32(self) -> i32;
  }

  impl<'a, T: Copy + AsI32> AsI32 for &'a T {
    fn as_i32(self) -> i32 {
      (*self).as_i32()
    }
  }
  
  impl AsI32 for i32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for char {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for usize {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  pub fn as_i64<T: AsI64>(t: T) -> i64 {
    t.as_i64()
  }

  pub trait AsI64 {
    fn as_i64(self) -> i64;
  }

  impl<'a, T: Copy + AsI64> AsI64 for &'a T {
    fn as_i64(self) -> i64 {
      (*self).as_i64()
    }
  }
  
  impl AsI64 for i64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  
  impl AsI64 for u64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  pub use alloc_crate::string::String;
  pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
    if cfg!(debug_assertions) {
      String::from_utf8(bytes).unwrap()
    } else {
      String::from_utf8_unchecked(bytes)
    }
  }
  pub use alloc_crate::boxed::Box;

  #[cfg(target_arch = "wasm32")]
  pub fn run_ctors_once() {
    wit_bindgen::rt::run_ctors_once();
  }
  pub use alloc_crate::alloc;
  extern crate alloc as alloc_crate;
}

/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_imports_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::component::usb::types::__export_component_usb_types_0_2_1_cabi!($ty with_types_in $($path_to_types_root)*::exports::component::usb::types);
  $($path_to_types_root)*::exports::component::usb::descriptors::__export_component_usb_descriptors_0_2_1_cabi!($ty with_types_in $($path_to_types_root)*::exports::component::usb::descriptors);
  $($path_to_types_root)*::exports::component::usb::usb::__export_component_usb_usb_0_2_1_cabi!($ty with_types_in $($path_to_types_root)*::exports::component::usb::usb);
  $($path_to_types_root)*::exports::component::usb::events::__export_component_usb_events_0_2_1_cabi!($ty with_types_in $($path_to_types_root)*::exports::component::usb::events);
  )
}
#[doc(inline)]
pub(crate) use __export_imports_impl as export;

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.24.0:imports:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 11340] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xceW\x01A\x02\x01A\x1c\
\x01B\x16\x01m\x02\x02in\x03out\x04\0\x12endpoint-direction\x03\0\0\x01m\x04\x07\
control\x0bisochronous\x04bulk\x09interrupt\x04\0\x16endpoint-transfer-type\x03\0\
\x02\x01m\x04\x07no-sync\x05async\x08adaptive\x0bsynchronous\x04\0\x12endpoint-s\
ync-type\x03\0\x04\x01m\x04\x04data\x08feedback\x0dfeedback-data\x08reserved\x04\
\0\x13endpoint-usage-type\x03\0\x06\x01r\x03\x05major}\x05minor}\x08subminor}\x04\
\0\x07version\x03\0\x08\x01m\x06\x07unknown\x03low\x04full\x04high\x05super\x09s\
uperplus\x04\0\x05speed\x03\0\x0a\x01m\x06\x0dinvalid-param\x07timeout\x04pipe\x08\
overflow\x09no-device\x02io\x04\0\x13device-handle-error\x03\0\x0c\x01w\x04\0\x08\
duration\x03\0\x0e\x01qJ\x09afrikaans\0\0\x08albanian\0\0\x06arabic\0\0\x08armen\
ian\0\0\x08assamese\0\0\x05azeri\0\0\x06basque\0\0\x0bbelarussian\0\0\x07bengali\
\0\0\x09bulgarian\0\0\x07burmese\0\0\x07catalan\0\0\x07chinese\0\0\x08croatian\0\
\0\x05czech\0\0\x06danish\0\0\x05dutch\0\0\x07english\0\0\x08estonian\0\0\x08fae\
roese\0\0\x05farsi\0\0\x07finnish\0\0\x06french\0\0\x08georgian\0\0\x06german\0\0\
\x05greek\0\0\x08gujarati\0\0\x06hebrew\0\0\x05hindi\0\0\x09hungarian\0\0\x09ice\
landic\0\0\x0aindonesian\0\0\x07italian\0\0\x08japanese\0\0\x07kannada\0\0\x08ka\
shmiri\0\0\x06kazakh\0\0\x07konkani\0\0\x06korean\0\0\x07latvian\0\0\x0alithuani\
an\0\0\x0amacedonian\0\0\x05malay\0\0\x09malayalam\0\0\x08manipuri\0\0\x07marath\
i\0\0\x06nepali\0\0\x09norwegian\0\0\x05oriya\0\0\x06polish\0\0\x0aportuguese\0\0\
\x07punjabi\0\0\x08romanian\0\0\x07russian\0\0\x08sanskrit\0\0\x07serbian\0\0\x06\
sindhi\0\0\x06slovak\0\0\x09slovenian\0\0\x07spanish\0\0\x04sutu\0\0\x07swahili\0\
\0\x07swedish\0\0\x05tamil\0\0\x05tatar\0\0\x06telugu\0\0\x04thai\0\0\x07turkish\
\0\0\x09ukrainian\0\0\x04urdu\0\0\x05uzbek\0\0\x0avietnamese\0\0\x03hid\0\0\x05o\
ther\x01{\0\x04\0\x10primary-language\x03\0\x10\x01qP\x08standard\0\0\x07classic\
\0\0\x0btraditional\0\0\x06modern\0\0\x07algeria\0\0\x09argentina\0\0\x09austral\
ia\0\0\x07austria\0\0\x07bahrain\0\0\x07belgium\0\0\x06belize\0\0\x06bokmal\0\0\x07\
bolivia\0\0\x06brazil\0\0\x11brunei-darussalam\0\0\x06canada\0\0\x09caribbean\0\0\
\x05chile\0\0\x05china\0\0\x08colombia\0\0\x0acosta-rica\0\0\x08cyrillic\0\0\x12\
dominican-republic\0\0\x07ecuador\0\0\x05egypt\0\0\x0bel-salvador\0\0\x07finland\
\0\0\x09guatemala\0\0\x08honduras\0\0\x09hong-kong\0\0\x05india\0\0\x04iraq\0\0\x07\
ireland\0\0\x07jamaica\0\0\x05johab\0\0\x06jordan\0\0\x06kuwait\0\0\x05latin\0\0\
\x07lebanon\0\0\x05libya\0\0\x0dliechtenstein\0\0\x0aluxembourg\0\0\x05macau\0\0\
\x08malaysia\0\0\x06mexico\0\0\x06monaco\0\0\x07morocco\0\0\x0bnetherlands\0\0\x0b\
new-zealand\0\0\x09nicaragua\0\0\x07nynorsk\0\0\x04oman\0\0\x08pakistan\0\0\x06p\
anama\0\0\x08paraguay\0\0\x04peru\0\0\x0bphilippines\0\0\x0bpuerto-rico\0\0\x05q\
atar\0\0\x0csaudi-arabia\0\0\x09singapore\0\0\x0csouth-africa\0\0\x0bswitzerland\
\0\0\x05syria\0\0\x06taiwan\0\0\x08trinidad\0\0\x07tunisia\0\0\x14united-arab-em\
irates\0\0\x0eunited-kingdom\0\0\x0dunited-states\0\0\x07uruguay\0\0\x09venezuel\
a\0\0\x05yemen\0\0\x08zimbabwe\0\0\x15usage-data-descriptor\0\0\x0fvendor-define\
d1\0\0\x0fvendor-defined2\0\0\x0fvendor-defined3\0\0\x0fvendor-defined4\0\0\x05o\
ther\x01{\0\x04\0\x0csub-language\x03\0\x12\x01r\x03\x02id{\x10primary-language\x11\
\x0csub-language\x13\x04\0\x08language\x03\0\x14\x03\x01\x19component:usb/types@\
0.2.1\x05\0\x02\x03\0\0\x12endpoint-direction\x02\x03\0\0\x16endpoint-transfer-t\
ype\x02\x03\0\0\x12endpoint-sync-type\x02\x03\0\0\x13endpoint-usage-type\x02\x03\
\0\0\x07version\x01B\x18\x02\x03\x02\x01\x01\x04\0\x12endpoint-direction\x03\0\0\
\x02\x03\x02\x01\x02\x04\0\x16endpoint-transfer-type\x03\0\x02\x02\x03\x02\x01\x03\
\x04\0\x12endpoint-sync-type\x03\0\x04\x02\x03\x02\x01\x04\x04\0\x13endpoint-usa\
ge-type\x03\0\x06\x02\x03\x02\x01\x05\x04\0\x07version\x03\0\x08\x01r\x0a\x07add\
ress}\x06number}\x09direction\x01\x0dtransfer-type\x03\x0fmax-packet-size{\x09sy\
nc-type\x05\x0ausage-type\x07\x10polling-interval}\x0crefresh-rate}\x0dsynch-add\
ress}\x04\0\x13endpoint-descriptor\x03\0\x0a\x01k}\x01p\x0b\x01r\x08\x10interfac\
e-number}\x0esetting-number}\x0aclass-code}\x0dsubclass-code}\x0dprotocol-code}\x0b\
description\x0c\x0dnum-endpoints}\x09endpoints\x0d\x04\0\x14interface-descriptor\
\x03\0\x0e\x01p\x0f\x01r\x02\x06number}\x15interface-descriptors\x10\x04\0\x10de\
vice-interface\x03\0\x11\x01p\x12\x01r\x07\x06number}\x09max-power{\x0cself-powe\
red\x7f\x0dremote-wakeup\x7f\x0bdescription\x0c\x0enum-interfaces}\x0ainterfaces\
\x13\x04\0\x11config-descriptor\x03\0\x14\x01r\x0c\x0busb-version\x09\x0edevice-\
version\x09\x13manufacturer-string\x0c\x0eproduct-string\x0c\x14serial-number-st\
ring\x0c\x0aclass-code}\x0dsubclass-code}\x0dprotocol-code}\x09vendor-id{\x0apro\
duct-id{\x0fmax-packet-size}\x12num-configurations}\x04\0\x11device-descriptor\x03\
\0\x16\x03\x01\x1fcomponent:usb/descriptors@0.2.1\x05\x06\x02\x03\0\x01\x11devic\
e-descriptor\x02\x03\0\x01\x11config-descriptor\x02\x03\0\0\x05speed\x02\x03\0\0\
\x08duration\x02\x03\0\0\x13device-handle-error\x02\x03\0\0\x08language\x01Ba\x02\
\x03\x02\x01\x07\x04\0\x11device-descriptor\x03\0\0\x02\x03\x02\x01\x08\x04\0\x11\
config-descriptor\x03\0\x02\x02\x03\x02\x01\x09\x04\0\x05speed\x03\0\x04\x02\x03\
\x02\x01\x0a\x04\0\x08duration\x03\0\x06\x02\x03\x02\x01\x0b\x04\0\x13device-han\
dle-error\x03\0\x08\x02\x03\x02\x01\x0c\x04\0\x08language\x03\0\x0a\x04\0\x0ausb\
-device\x03\x01\x04\0\x07context\x03\x01\x04\0\x0ddevice-handle\x03\x01\x01h\x0c\
\x01j\x01\x01\0\x01@\x01\x04self\x0f\0\x10\x04\0$[method]usb-device.device-descr\
iptor\x01\x11\x01j\x01\x03\0\x01@\x01\x04self\x0f\0\x12\x04\0$[method]usb-device\
.config-descriptor\x01\x13\x01@\x01\x04self\x0f\0}\x04\0\x1d[method]usb-device.b\
us-number\x01\x14\x04\0\x1a[method]usb-device.address\x01\x14\x01@\x01\x04self\x0f\
\0\x05\x04\0\x18[method]usb-device.speed\x01\x15\x01i\x0e\x01j\x01\x16\0\x01@\x01\
\x04self\x0f\0\x17\x04\0\x17[method]usb-device.open\x01\x18\x04\0\x1e[method]usb\
-device.port-number\x01\x14\x01h\x0d\x01i\x0c\x01p\x1a\x01j\x01\x1b\0\x01@\x01\x04\
self\x19\0\x1c\x04\0\x17[method]context.devices\x01\x1d\x01k\x16\x01@\x03\x04sel\
f\x19\x09vendor-id{\x0aproduct-id{\0\x1e\x04\0([method]context.open-device-with-\
vid-pid\x01\x1f\x01h\x0e\x01@\x01\x04self\x20\0\x1a\x04\0\x1c[method]device-hand\
le.device\x01!\x01j\x01}\0\x01@\x01\x04self\x20\0\"\x04\0*[method]device-handle.\
active-configuration\x01#\x01j\0\0\x01@\x02\x04self\x20\x06config}\0$\x04\0.[met\
hod]device-handle.set-active-configuration\x01%\x01@\x01\x04self\x20\0$\x04\0![m\
ethod]device-handle.unconfigure\x01&\x04\0\x1b[method]device-handle.reset\x01&\x01\
@\x02\x04self\x20\x08endpoint}\0$\x04\0\x20[method]device-handle.clear-halt\x01'\
\x01j\x01\x7f\0\x01@\x01\x04self\x20\0(\x04\0*[method]device-handle.kernel-drive\
r-active\x01)\x04\0*[method]device-handle.detach-kernel-driver\x01&\x04\0*[metho\
d]device-handle.attach-kernel-driver\x01&\x01@\x02\x04self\x20\x04auto\x7f\0$\x04\
\0:[method]device-handle.set-auto-attach-detach-kernel-driver\x01*\x01@\x02\x04s\
elf\x20\x05iface}\0$\x04\0%[method]device-handle.claim-interface\x01+\x04\0'[met\
hod]device-handle.release-interface\x01+\x01@\x03\x04self\x20\x05iface}\x0balt-s\
etting}\0$\x04\0/[method]device-handle.set-interface-alt-setting\x01,\x01p}\x01o\
\x02w-\x01j\x01.\x01\x09\x01@\x03\x04self\x20\x08endpoint}\x07timeout\x07\0/\x04\
\0$[method]device-handle.read-interrupt\x010\x01j\x01w\x01\x09\x01@\x04\x04self\x20\
\x08endpoint}\x04data-\x07timeout\x07\01\x04\0%[method]device-handle.write-inter\
rupt\x012\x01@\x04\x04self\x20\x08endpoint}\x08max-sizew\x07timeout\x07\0/\x04\0\
\x1f[method]device-handle.read-bulk\x013\x04\0\x20[method]device-handle.write-bu\
lk\x012\x01@\x07\x04self\x20\x0crequest-type}\x07request}\x05value{\x05index{\x08\
max-size{\x07timeout\x07\0/\x04\0\"[method]device-handle.read-control\x014\x01@\x07\
\x04self\x20\x0crequest-type}\x07request}\x05value{\x05index{\x04data-\x07timeou\
t\x07\01\x04\0#[method]device-handle.write-control\x015\x01p\x0b\x01j\x016\0\x01\
@\x02\x04self\x20\x07timeout\x07\07\x04\0$[method]device-handle.read-languages\x01\
8\x01j\x01s\0\x01@\x02\x04self\x20\x05index}\09\x04\02[method]device-handle.read\
-string-descriptor-ascii\x01:\x01@\x04\x04self\x20\x08language\x0b\x05index}\x07\
timeout\x07\09\x04\0,[method]device-handle.read-string-descriptor\x01;\x01@\x02\x04\
self\x20\x06device\x01\x01\0\x04\04[method]device-handle.read-manufacturer-strin\
g-ascii\x01<\x01i\x0d\x01j\x01=\0\x01@\0\0>\x04\0\x0bget-context\x01?\x03\x01\x17\
component:usb/usb@0.2.1\x05\x0d\x02\x03\0\x02\x0ausb-device\x01B\x07\x02\x03\x02\
\x01\x0e\x04\0\x0ausb-device\x03\0\0\x01i\x01\x01q\x03\x07pending\0\0\x09connect\
ed\x01\x02\0\x0cdisconnected\x01\x02\0\x04\0\x17device-connection-event\x03\0\x03\
\x01@\0\0\x04\x04\0\x06update\x01\x05\x03\x01\x1acomponent:usb/events@0.2.1\x05\x0f\
\x01B\x16\x01m\x02\x02in\x03out\x04\0\x12endpoint-direction\x03\0\0\x01m\x04\x07\
control\x0bisochronous\x04bulk\x09interrupt\x04\0\x16endpoint-transfer-type\x03\0\
\x02\x01m\x04\x07no-sync\x05async\x08adaptive\x0bsynchronous\x04\0\x12endpoint-s\
ync-type\x03\0\x04\x01m\x04\x04data\x08feedback\x0dfeedback-data\x08reserved\x04\
\0\x13endpoint-usage-type\x03\0\x06\x01r\x03\x05major}\x05minor}\x08subminor}\x04\
\0\x07version\x03\0\x08\x01m\x06\x07unknown\x03low\x04full\x04high\x05super\x09s\
uperplus\x04\0\x05speed\x03\0\x0a\x01m\x06\x0dinvalid-param\x07timeout\x04pipe\x08\
overflow\x09no-device\x02io\x04\0\x13device-handle-error\x03\0\x0c\x01w\x04\0\x08\
duration\x03\0\x0e\x01qJ\x09afrikaans\0\0\x08albanian\0\0\x06arabic\0\0\x08armen\
ian\0\0\x08assamese\0\0\x05azeri\0\0\x06basque\0\0\x0bbelarussian\0\0\x07bengali\
\0\0\x09bulgarian\0\0\x07burmese\0\0\x07catalan\0\0\x07chinese\0\0\x08croatian\0\
\0\x05czech\0\0\x06danish\0\0\x05dutch\0\0\x07english\0\0\x08estonian\0\0\x08fae\
roese\0\0\x05farsi\0\0\x07finnish\0\0\x06french\0\0\x08georgian\0\0\x06german\0\0\
\x05greek\0\0\x08gujarati\0\0\x06hebrew\0\0\x05hindi\0\0\x09hungarian\0\0\x09ice\
landic\0\0\x0aindonesian\0\0\x07italian\0\0\x08japanese\0\0\x07kannada\0\0\x08ka\
shmiri\0\0\x06kazakh\0\0\x07konkani\0\0\x06korean\0\0\x07latvian\0\0\x0alithuani\
an\0\0\x0amacedonian\0\0\x05malay\0\0\x09malayalam\0\0\x08manipuri\0\0\x07marath\
i\0\0\x06nepali\0\0\x09norwegian\0\0\x05oriya\0\0\x06polish\0\0\x0aportuguese\0\0\
\x07punjabi\0\0\x08romanian\0\0\x07russian\0\0\x08sanskrit\0\0\x07serbian\0\0\x06\
sindhi\0\0\x06slovak\0\0\x09slovenian\0\0\x07spanish\0\0\x04sutu\0\0\x07swahili\0\
\0\x07swedish\0\0\x05tamil\0\0\x05tatar\0\0\x06telugu\0\0\x04thai\0\0\x07turkish\
\0\0\x09ukrainian\0\0\x04urdu\0\0\x05uzbek\0\0\x0avietnamese\0\0\x03hid\0\0\x05o\
ther\x01{\0\x04\0\x10primary-language\x03\0\x10\x01qP\x08standard\0\0\x07classic\
\0\0\x0btraditional\0\0\x06modern\0\0\x07algeria\0\0\x09argentina\0\0\x09austral\
ia\0\0\x07austria\0\0\x07bahrain\0\0\x07belgium\0\0\x06belize\0\0\x06bokmal\0\0\x07\
bolivia\0\0\x06brazil\0\0\x11brunei-darussalam\0\0\x06canada\0\0\x09caribbean\0\0\
\x05chile\0\0\x05china\0\0\x08colombia\0\0\x0acosta-rica\0\0\x08cyrillic\0\0\x12\
dominican-republic\0\0\x07ecuador\0\0\x05egypt\0\0\x0bel-salvador\0\0\x07finland\
\0\0\x09guatemala\0\0\x08honduras\0\0\x09hong-kong\0\0\x05india\0\0\x04iraq\0\0\x07\
ireland\0\0\x07jamaica\0\0\x05johab\0\0\x06jordan\0\0\x06kuwait\0\0\x05latin\0\0\
\x07lebanon\0\0\x05libya\0\0\x0dliechtenstein\0\0\x0aluxembourg\0\0\x05macau\0\0\
\x08malaysia\0\0\x06mexico\0\0\x06monaco\0\0\x07morocco\0\0\x0bnetherlands\0\0\x0b\
new-zealand\0\0\x09nicaragua\0\0\x07nynorsk\0\0\x04oman\0\0\x08pakistan\0\0\x06p\
anama\0\0\x08paraguay\0\0\x04peru\0\0\x0bphilippines\0\0\x0bpuerto-rico\0\0\x05q\
atar\0\0\x0csaudi-arabia\0\0\x09singapore\0\0\x0csouth-africa\0\0\x0bswitzerland\
\0\0\x05syria\0\0\x06taiwan\0\0\x08trinidad\0\0\x07tunisia\0\0\x14united-arab-em\
irates\0\0\x0eunited-kingdom\0\0\x0dunited-states\0\0\x07uruguay\0\0\x09venezuel\
a\0\0\x05yemen\0\0\x08zimbabwe\0\0\x15usage-data-descriptor\0\0\x0fvendor-define\
d1\0\0\x0fvendor-defined2\0\0\x0fvendor-defined3\0\0\x0fvendor-defined4\0\0\x05o\
ther\x01{\0\x04\0\x0csub-language\x03\0\x12\x01r\x03\x02id{\x10primary-language\x11\
\x0csub-language\x13\x04\0\x08language\x03\0\x14\x04\x01\x19component:usb/types@\
0.2.1\x05\x10\x01B\x18\x02\x03\x02\x01\x01\x04\0\x12endpoint-direction\x03\0\0\x02\
\x03\x02\x01\x02\x04\0\x16endpoint-transfer-type\x03\0\x02\x02\x03\x02\x01\x03\x04\
\0\x12endpoint-sync-type\x03\0\x04\x02\x03\x02\x01\x04\x04\0\x13endpoint-usage-t\
ype\x03\0\x06\x02\x03\x02\x01\x05\x04\0\x07version\x03\0\x08\x01r\x0a\x07address\
}\x06number}\x09direction\x01\x0dtransfer-type\x03\x0fmax-packet-size{\x09sync-t\
ype\x05\x0ausage-type\x07\x10polling-interval}\x0crefresh-rate}\x0dsynch-address\
}\x04\0\x13endpoint-descriptor\x03\0\x0a\x01k}\x01p\x0b\x01r\x08\x10interface-nu\
mber}\x0esetting-number}\x0aclass-code}\x0dsubclass-code}\x0dprotocol-code}\x0bd\
escription\x0c\x0dnum-endpoints}\x09endpoints\x0d\x04\0\x14interface-descriptor\x03\
\0\x0e\x01p\x0f\x01r\x02\x06number}\x15interface-descriptors\x10\x04\0\x10device\
-interface\x03\0\x11\x01p\x12\x01r\x07\x06number}\x09max-power{\x0cself-powered\x7f\
\x0dremote-wakeup\x7f\x0bdescription\x0c\x0enum-interfaces}\x0ainterfaces\x13\x04\
\0\x11config-descriptor\x03\0\x14\x01r\x0c\x0busb-version\x09\x0edevice-version\x09\
\x13manufacturer-string\x0c\x0eproduct-string\x0c\x14serial-number-string\x0c\x0a\
class-code}\x0dsubclass-code}\x0dprotocol-code}\x09vendor-id{\x0aproduct-id{\x0f\
max-packet-size}\x12num-configurations}\x04\0\x11device-descriptor\x03\0\x16\x04\
\x01\x1fcomponent:usb/descriptors@0.2.1\x05\x11\x01Ba\x02\x03\x02\x01\x07\x04\0\x11\
device-descriptor\x03\0\0\x02\x03\x02\x01\x08\x04\0\x11config-descriptor\x03\0\x02\
\x02\x03\x02\x01\x09\x04\0\x05speed\x03\0\x04\x02\x03\x02\x01\x0a\x04\0\x08durat\
ion\x03\0\x06\x02\x03\x02\x01\x0b\x04\0\x13device-handle-error\x03\0\x08\x02\x03\
\x02\x01\x0c\x04\0\x08language\x03\0\x0a\x04\0\x0ausb-device\x03\x01\x04\0\x07co\
ntext\x03\x01\x04\0\x0ddevice-handle\x03\x01\x01h\x0c\x01j\x01\x01\0\x01@\x01\x04\
self\x0f\0\x10\x04\0$[method]usb-device.device-descriptor\x01\x11\x01j\x01\x03\0\
\x01@\x01\x04self\x0f\0\x12\x04\0$[method]usb-device.config-descriptor\x01\x13\x01\
@\x01\x04self\x0f\0}\x04\0\x1d[method]usb-device.bus-number\x01\x14\x04\0\x1a[me\
thod]usb-device.address\x01\x14\x01@\x01\x04self\x0f\0\x05\x04\0\x18[method]usb-\
device.speed\x01\x15\x01i\x0e\x01j\x01\x16\0\x01@\x01\x04self\x0f\0\x17\x04\0\x17\
[method]usb-device.open\x01\x18\x04\0\x1e[method]usb-device.port-number\x01\x14\x01\
h\x0d\x01i\x0c\x01p\x1a\x01j\x01\x1b\0\x01@\x01\x04self\x19\0\x1c\x04\0\x17[meth\
od]context.devices\x01\x1d\x01k\x16\x01@\x03\x04self\x19\x09vendor-id{\x0aproduc\
t-id{\0\x1e\x04\0([method]context.open-device-with-vid-pid\x01\x1f\x01h\x0e\x01@\
\x01\x04self\x20\0\x1a\x04\0\x1c[method]device-handle.device\x01!\x01j\x01}\0\x01\
@\x01\x04self\x20\0\"\x04\0*[method]device-handle.active-configuration\x01#\x01j\
\0\0\x01@\x02\x04self\x20\x06config}\0$\x04\0.[method]device-handle.set-active-c\
onfiguration\x01%\x01@\x01\x04self\x20\0$\x04\0![method]device-handle.unconfigur\
e\x01&\x04\0\x1b[method]device-handle.reset\x01&\x01@\x02\x04self\x20\x08endpoin\
t}\0$\x04\0\x20[method]device-handle.clear-halt\x01'\x01j\x01\x7f\0\x01@\x01\x04\
self\x20\0(\x04\0*[method]device-handle.kernel-driver-active\x01)\x04\0*[method]\
device-handle.detach-kernel-driver\x01&\x04\0*[method]device-handle.attach-kerne\
l-driver\x01&\x01@\x02\x04self\x20\x04auto\x7f\0$\x04\0:[method]device-handle.se\
t-auto-attach-detach-kernel-driver\x01*\x01@\x02\x04self\x20\x05iface}\0$\x04\0%\
[method]device-handle.claim-interface\x01+\x04\0'[method]device-handle.release-i\
nterface\x01+\x01@\x03\x04self\x20\x05iface}\x0balt-setting}\0$\x04\0/[method]de\
vice-handle.set-interface-alt-setting\x01,\x01p}\x01o\x02w-\x01j\x01.\x01\x09\x01\
@\x03\x04self\x20\x08endpoint}\x07timeout\x07\0/\x04\0$[method]device-handle.rea\
d-interrupt\x010\x01j\x01w\x01\x09\x01@\x04\x04self\x20\x08endpoint}\x04data-\x07\
timeout\x07\01\x04\0%[method]device-handle.write-interrupt\x012\x01@\x04\x04self\
\x20\x08endpoint}\x08max-sizew\x07timeout\x07\0/\x04\0\x1f[method]device-handle.\
read-bulk\x013\x04\0\x20[method]device-handle.write-bulk\x012\x01@\x07\x04self\x20\
\x0crequest-type}\x07request}\x05value{\x05index{\x08max-size{\x07timeout\x07\0/\
\x04\0\"[method]device-handle.read-control\x014\x01@\x07\x04self\x20\x0crequest-\
type}\x07request}\x05value{\x05index{\x04data-\x07timeout\x07\01\x04\0#[method]d\
evice-handle.write-control\x015\x01p\x0b\x01j\x016\0\x01@\x02\x04self\x20\x07tim\
eout\x07\07\x04\0$[method]device-handle.read-languages\x018\x01j\x01s\0\x01@\x02\
\x04self\x20\x05index}\09\x04\02[method]device-handle.read-string-descriptor-asc\
ii\x01:\x01@\x04\x04self\x20\x08language\x0b\x05index}\x07timeout\x07\09\x04\0,[\
method]device-handle.read-string-descriptor\x01;\x01@\x02\x04self\x20\x06device\x01\
\x01\0\x04\04[method]device-handle.read-manufacturer-string-ascii\x01<\x01i\x0d\x01\
j\x01=\0\x01@\0\0>\x04\0\x0bget-context\x01?\x04\x01\x17component:usb/usb@0.2.1\x05\
\x12\x01B\x07\x02\x03\x02\x01\x0e\x04\0\x0ausb-device\x03\0\0\x01i\x01\x01q\x03\x07\
pending\0\0\x09connected\x01\x02\0\x0cdisconnected\x01\x02\0\x04\0\x17device-con\
nection-event\x03\0\x03\x01@\0\0\x04\x04\0\x06update\x01\x05\x04\x01\x1acomponen\
t:usb/events@0.2.1\x05\x13\x04\x01\x1bcomponent:usb/imports@0.2.1\x04\0\x0b\x0d\x01\
\0\x07imports\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x07\
0.202.0\x10wit-bindgen-rust\x060.24.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

