// Generated by `wit-bindgen` 0.42.1. DO NOT EDIT!
#ifndef __BINDINGS_CGUEST_H
#define __BINDINGS_CGUEST_H
#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

// Libusb error codes (negative values indicate errors)
typedef uint8_t component_usb_errors_libusb_error_t;

// LIBUSB_ERROR_IO: Input/output error
#define COMPONENT_USB_ERRORS_LIBUSB_ERROR_IO 0
// LIBUSB_ERROR_INVALID_PARAM: Invalid parameter
#define COMPONENT_USB_ERRORS_LIBUSB_ERROR_INVALID_PARAM 1
// LIBUSB_ERROR_ACCESS: Access denied / permission issue
#define COMPONENT_USB_ERRORS_LIBUSB_ERROR_ACCESS 2
// LIBUSB_ERROR_NO_DEVICE: Device disconnected
#define COMPONENT_USB_ERRORS_LIBUSB_ERROR_NO_DEVICE 3
// LIBUSB_ERROR_NOT_FOUND: Entity not found
#define COMPONENT_USB_ERRORS_LIBUSB_ERROR_NOT_FOUND 4
// LIBUSB_ERROR_BUSY: Resource busy
#define COMPONENT_USB_ERRORS_LIBUSB_ERROR_BUSY 5
// LIBUSB_ERROR_TIMEOUT: Operation timed out
#define COMPONENT_USB_ERRORS_LIBUSB_ERROR_TIMEOUT 6
// LIBUSB_ERROR_OVERFLOW: Overflow
#define COMPONENT_USB_ERRORS_LIBUSB_ERROR_OVERFLOW 7
// LIBUSB_ERROR_PIPE: Pipe error (stall)
#define COMPONENT_USB_ERRORS_LIBUSB_ERROR_PIPE 8
// LIBUSB_ERROR_INTERRUPTED: System call interrupted
#define COMPONENT_USB_ERRORS_LIBUSB_ERROR_INTERRUPTED 9
// LIBUSB_ERROR_NO_MEM: Insufficient memory
#define COMPONENT_USB_ERRORS_LIBUSB_ERROR_NO_MEM 10
// LIBUSB_ERROR_NOT_SUPPORTED: Not supported on this platform
#define COMPONENT_USB_ERRORS_LIBUSB_ERROR_NOT_SUPPORTED 11
// LIBUSB_ERROR_OTHER: Other error
#define COMPONENT_USB_ERRORS_LIBUSB_ERROR_OTHER 12

typedef component_usb_errors_libusb_error_t component_usb_transfers_libusb_error_t;

// USB transfer type codes
typedef uint8_t component_usb_transfers_transfer_type_t;

#define COMPONENT_USB_TRANSFERS_TRANSFER_TYPE_CONTROL 0
// Control transfer (setup packet + optional data)
#define COMPONENT_USB_TRANSFERS_TRANSFER_TYPE_BULK 1
// Bulk transfer
#define COMPONENT_USB_TRANSFERS_TRANSFER_TYPE_INTERRUPT 2
// Interrupt transfer
#define COMPONENT_USB_TRANSFERS_TRANSFER_TYPE_ISOCHRONOUS 3

typedef struct component_usb_transfers_transfer_setup_t {
  uint8_t   bm_request_type;
  // Request type (direction, type, recipient)
  uint8_t   b_request;
  // Request (bRequest)
  uint16_t   w_value;
  // Value (wValue)
  uint16_t   w_index;
} component_usb_transfers_transfer_setup_t;

// USB transfer options
typedef struct component_usb_transfers_transfer_options_t {
  uint8_t   endpoint;
  // Endpoint address (number + direction)
  uint32_t   timeout_ms;
  // Timeout in milliseconds
  uint32_t   stream_id;
  // Stream ID for USB 3.0 bulk streams
  uint32_t   iso_packets;
} component_usb_transfers_transfer_options_t;

typedef struct component_usb_transfers_own_transfer_t {
  int32_t __handle;
} component_usb_transfers_own_transfer_t;

typedef struct component_usb_transfers_borrow_transfer_t {
  int32_t __handle;
} component_usb_transfers_borrow_transfer_t;

typedef struct {
  uint8_t *ptr;
  size_t len;
} cguest_list_u8_t;

typedef struct {
  bool is_err;
  union {
    component_usb_transfers_libusb_error_t err;
  } val;
} component_usb_transfers_result_void_libusb_error_t;

typedef struct {
  bool is_err;
  union {
    cguest_list_u8_t ok;
    component_usb_transfers_libusb_error_t err;
  } val;
} component_usb_transfers_result_list_u8_libusb_error_t;

// ConfigValue is used to specify a configuration or an unconfigured state.
typedef struct component_usb_configuration_config_value_t {
  uint8_t tag;
  union {
    uint8_t     value;
  } val;
} component_usb_configuration_config_value_t;

#define COMPONENT_USB_CONFIGURATION_CONFIG_VALUE_UNCONFIGURED 0
// Corresponds to -1 in libusb (unconfigure device)
#define COMPONENT_USB_CONFIGURATION_CONFIG_VALUE_VALUE 1

typedef component_usb_errors_libusb_error_t component_usb_descriptors_libusb_error_t;

// USB Device Descriptor (18 bytes)
typedef struct component_usb_descriptors_device_descriptor_t {
  uint8_t   length;
  // Size of this descriptor in bytes (should be 18)
  uint8_t   descriptor_type;
  // DEVICE descriptor type (1)
  uint16_t   usb_version_bcd;
  // USB specification version (bcdUSB)
  uint8_t   device_class;
  // Class code (bDeviceClass)
  uint8_t   device_subclass;
  // Subclass code (bDeviceSubClass)
  uint8_t   device_protocol;
  // Protocol code (bDeviceProtocol)
  uint8_t   max_packet_size0;
  // Max packet size for endpoint 0
  uint16_t   vendor_id;
  // Vendor ID (idVendor)
  uint16_t   product_id;
  // Product ID (idProduct)
  uint16_t   device_version_bcd;
  // Device release number (bcdDevice)
  uint8_t   manufacturer_index;
  // Index of string descriptor for manufacturer
  uint8_t   product_index;
  // Index of string descriptor for product
  uint8_t   serial_number_index;
  // Index of string descriptor for serial number
  uint8_t   num_configurations;
} component_usb_descriptors_device_descriptor_t;

// USB Configuration Descriptor (9 bytes)
typedef struct component_usb_descriptors_configuration_descriptor_t {
  uint8_t   length;
  // Size of this descriptor in bytes (should be 9)
  uint8_t   descriptor_type;
  // CONFIGURATION descriptor type (2)
  uint16_t   total_length;
  // Total length of data including all sub-descriptors
  uint8_t   num_interfaces;
  // Number of interfaces
  uint8_t   configuration_value;
  // Value to use for SetConfiguration
  uint8_t   configuration_index;
  // Index of string descriptor describing this configuration
  uint8_t   attributes;
  // Bitmap: self/bus powered, remote wakeup
  uint8_t   max_power;
} component_usb_descriptors_configuration_descriptor_t;

// USB Interface Descriptor (9 bytes)
typedef struct component_usb_descriptors_interface_descriptor_t {
  uint8_t   length;
  // Size of this descriptor in bytes (should be 9)
  uint8_t   descriptor_type;
  // INTERFACE descriptor type (4)
  uint8_t   interface_number;
  // Number of this interface
  uint8_t   alternate_setting;
  // Value to select alternate setting
  uint8_t   num_endpoints;
  // Number of endpoints (excluding endpoint 0)
  uint8_t   interface_class;
  // Class code
  uint8_t   interface_subclass;
  // Subclass code
  uint8_t   interface_protocol;
  // Protocol code
  uint8_t   interface_index;
} component_usb_descriptors_interface_descriptor_t;

// USB Endpoint Descriptor (7+ bytes)
typedef struct component_usb_descriptors_endpoint_descriptor_t {
  uint8_t   length;
  // Size of this descriptor in bytes (should be 7)
  uint8_t   descriptor_type;
  // ENDPOINT descriptor type (5)
  uint8_t   endpoint_address;
  // Endpoint number and direction (bitmask)
  uint8_t   attributes;
  // Transfer type and synchronization type
  uint16_t   max_packet_size;
  // Max packet size this endpoint can handle
  uint8_t   interval;
  // Polling interval (in ms for interrupt/bulk)
  uint8_t   refresh;
  // (Isochronous) Data rate refresh interval
  uint8_t   synch_address;
} component_usb_descriptors_endpoint_descriptor_t;

typedef component_usb_errors_libusb_error_t component_usb_device_libusb_error_t;

typedef component_usb_configuration_config_value_t component_usb_device_config_value_t;

typedef component_usb_descriptors_device_descriptor_t component_usb_device_device_descriptor_t;

typedef component_usb_descriptors_configuration_descriptor_t component_usb_device_configuration_descriptor_t;

typedef component_usb_descriptors_interface_descriptor_t component_usb_device_interface_descriptor_t;

typedef component_usb_descriptors_endpoint_descriptor_t component_usb_device_endpoint_descriptor_t;

typedef component_usb_transfers_transfer_type_t component_usb_device_transfer_type_t;

typedef component_usb_transfers_transfer_setup_t component_usb_device_transfer_setup_t;

typedef component_usb_transfers_transfer_options_t component_usb_device_transfer_options_t;

typedef struct component_usb_device_own_usb_device_t {
  int32_t __handle;
} component_usb_device_own_usb_device_t;

typedef struct component_usb_device_borrow_usb_device_t {
  int32_t __handle;
} component_usb_device_borrow_usb_device_t;

typedef struct component_usb_device_own_device_handle_t {
  int32_t __handle;
} component_usb_device_own_device_handle_t;

typedef struct component_usb_device_borrow_device_handle_t {
  int32_t __handle;
} component_usb_device_borrow_device_handle_t;

typedef struct {
  bool is_err;
  union {
    component_usb_device_own_device_handle_t ok;
    component_usb_device_libusb_error_t err;
  } val;
} component_usb_device_result_own_device_handle_libusb_error_t;

typedef struct {
  bool is_err;
  union {
    component_usb_device_configuration_descriptor_t ok;
    component_usb_device_libusb_error_t err;
  } val;
} component_usb_device_result_configuration_descriptor_libusb_error_t;

typedef struct {
  bool is_err;
  union {
    uint8_t ok;
    component_usb_device_libusb_error_t err;
  } val;
} component_usb_device_result_u8_libusb_error_t;

typedef struct {
  bool is_err;
  union {
    component_usb_device_libusb_error_t err;
  } val;
} component_usb_device_result_void_libusb_error_t;

typedef struct {
  bool is_err;
  union {
    bool ok;
    component_usb_device_libusb_error_t err;
  } val;
} component_usb_device_result_bool_libusb_error_t;

typedef component_usb_transfers_own_transfer_t component_usb_device_own_transfer_t;

typedef struct {
  bool is_err;
  union {
    component_usb_device_own_transfer_t ok;
    component_usb_device_libusb_error_t err;
  } val;
} component_usb_device_result_own_transfer_libusb_error_t;

typedef struct {
  component_usb_device_own_usb_device_t *ptr;
  size_t len;
} component_usb_device_list_own_usb_device_t;

typedef struct {
  bool is_err;
  union {
    component_usb_device_list_own_usb_device_t ok;
    component_usb_device_libusb_error_t err;
  } val;
} component_usb_device_result_list_own_usb_device_libusb_error_t;

typedef component_usb_errors_libusb_error_t component_usb_usb_hotplug_libusb_error_t;

typedef uint8_t component_usb_usb_hotplug_event_t;

#define COMPONENT_USB_USB_HOTPLUG_EVENT_ARRIVED (1 << 0)
#define COMPONENT_USB_USB_HOTPLUG_EVENT_LEFT (1 << 1)

typedef struct component_usb_usb_hotplug_info_t {
  uint8_t   bus;
  uint8_t   address;
  uint16_t   vendor;
  uint16_t   product;
} component_usb_usb_hotplug_info_t;

typedef struct {
  bool is_err;
  union {
    component_usb_usb_hotplug_libusb_error_t err;
  } val;
} component_usb_usb_hotplug_result_void_libusb_error_t;

typedef component_usb_device_own_usb_device_t component_usb_usb_hotplug_own_usb_device_t;

typedef struct {
  component_usb_usb_hotplug_event_t f0;
  component_usb_usb_hotplug_info_t f1;
  component_usb_usb_hotplug_own_usb_device_t f2;
} component_usb_usb_hotplug_tuple3_event_info_own_usb_device_t;

typedef struct {
  component_usb_usb_hotplug_tuple3_event_info_own_usb_device_t *ptr;
  size_t len;
} component_usb_usb_hotplug_list_tuple3_event_info_own_usb_device_t;

typedef struct {
  bool is_err;
} exports_wasi_cli_run_result_void_void_t;

// Imported Functions from `component:usb/transfers@0.2.1`
// Submit a transfer to the USB device with the data
// The transfer is submitted to the device and will be processed asynchronously.
extern bool component_usb_transfers_method_transfer_submit_transfer(component_usb_transfers_borrow_transfer_t self, cguest_list_u8_t *data, component_usb_transfers_libusb_error_t *err);
// Cancel a previously submitted transfer. This requests cancellation; actual completion (with status = cancelled) will occur asynchronously.
// Returns Ok(_) if cancellation was successfully initiated. If the transfer had already completed or was not found, an error may be returned (e.g., not_found).
extern bool component_usb_transfers_method_transfer_cancel_transfer(component_usb_transfers_borrow_transfer_t self, component_usb_transfers_libusb_error_t *err);
// Wait for the transfer to complete. This blocks until the transfer is done.
// Returns Ok(data) if the transfer completed successfully, or an error code if it failed.
// The data returned is the data received from the device (if applicable).
extern bool component_usb_transfers_await_transfer(component_usb_transfers_own_transfer_t xfer, cguest_list_u8_t *ret, component_usb_transfers_libusb_error_t *err);

// Imported Functions from `component:usb/device@0.2.1`
// Open a device and return a handle for I/O operations.
// The `device` must be one from the list_devices result.
// On success, returns a device-handle for the open device.
// Errors: access (permission denied), no_device (device disconnected), etc.
extern bool component_usb_device_method_usb_device_open(component_usb_device_borrow_usb_device_t self, component_usb_device_own_device_handle_t *ret, component_usb_device_libusb_error_t *err);
// Functions to retrieve descriptors
// get-device-descriptor: func() -> result<device-descriptor, libusb-error>;
extern bool component_usb_device_method_usb_device_get_configuration_descriptor(component_usb_device_borrow_usb_device_t self, uint8_t config_index, component_usb_device_configuration_descriptor_t *ret, component_usb_device_libusb_error_t *err);
extern bool component_usb_device_method_usb_device_get_configuration_descriptor_by_value(component_usb_device_borrow_usb_device_t self, uint8_t config_value, component_usb_device_configuration_descriptor_t *ret, component_usb_device_libusb_error_t *err);
// Get the currently active configuration value of an open device.
// On success, returns the bConfigurationValue (0 if unconfigured).
extern bool component_usb_device_method_device_handle_get_configuration(component_usb_device_borrow_device_handle_t self, uint8_t *ret, component_usb_device_libusb_error_t *err);
// Set the active configuration for a device.
// Use ConfigValue.unconfigured to unconfigure (set config 0), or ConfigValue.value(n) to set configuration 'n'.
// Returns an error if the device is busy or the configuration is invalid.
extern bool component_usb_device_method_device_handle_set_configuration(component_usb_device_borrow_device_handle_t self, component_usb_device_config_value_t *config, component_usb_device_libusb_error_t *err);
// Claim an iface on a device so it can be used by libusb.
// This should prepare the interface for I/O (detach kernel driver if needed, etc.).
extern bool component_usb_device_method_device_handle_claim_interface(component_usb_device_borrow_device_handle_t self, uint8_t ifac, component_usb_device_libusb_error_t *err);
// Release a previously claimed interface.
// This may perform a SET_INTERFACE to reset alt setting to 0.
extern bool component_usb_device_method_device_handle_release_interface(component_usb_device_borrow_device_handle_t self, uint8_t ifac, component_usb_device_libusb_error_t *err);
// Set the alternate setting for the specified interface (must be claimed first).
extern bool component_usb_device_method_device_handle_set_interface_altsetting(component_usb_device_borrow_device_handle_t self, uint8_t ifac, uint8_t alt_setting, component_usb_device_libusb_error_t *err);
// Clear the halt/stall condition on the given endpoint (endpoint number with direction bit).
// After this, the endpoint can be used again for transfers.
extern bool component_usb_device_method_device_handle_clear_halt(component_usb_device_borrow_device_handle_t self, uint8_t endpoint, component_usb_device_libusb_error_t *err);
// Perform a USB port reset on the device.
// If successful, the device will re-enumerate. The handle remains valid if the device can be re-opened.
extern bool component_usb_device_method_device_handle_reset_device(component_usb_device_borrow_device_handle_t self, component_usb_device_libusb_error_t *err);
// Allocate a USB 3 bulk stream
// This is used for bulk transfers with USB 3.0 devices.
extern bool component_usb_device_method_device_handle_alloc_streams(component_usb_device_borrow_device_handle_t self, uint32_t num_streams, cguest_list_u8_t *endpoints, component_usb_device_libusb_error_t *err);
// Free a previously allocated USB 3 bulk stream
// This is used for bulk transfers with USB 3.0 devices.
extern bool component_usb_device_method_device_handle_free_streams(component_usb_device_borrow_device_handle_t self, cguest_list_u8_t *endpoints, component_usb_device_libusb_error_t *err);
// Check if a kernel driver is active on the given interface.
// Returns: Ok(true) if a kernel driver is active, Ok(false) if not;
// LIBUSB_ERROR_NO_DEVICE if device is gone. This is optional.
extern bool component_usb_device_method_device_handle_kernel_driver_active(component_usb_device_borrow_device_handle_t self, uint8_t ifac, bool *ret, component_usb_device_libusb_error_t *err);
// Detach the kernel driver from an interface, if one is active.
// After this, libusb can claim the interface. Optional; not all platforms support it.
extern bool component_usb_device_method_device_handle_detach_kernel_driver(component_usb_device_borrow_device_handle_t self, uint8_t ifac, component_usb_device_libusb_error_t *err);
// Re-attach the kernel driver to an interface. Optional.
// Should only be called if a driver was previously detached.
extern bool component_usb_device_method_device_handle_attach_kernel_driver(component_usb_device_borrow_device_handle_t self, uint8_t ifac, component_usb_device_libusb_error_t *err);
// Submit an asynchronous USB transfer on an open device handle.
// - `endpoint`: Endpoint address (with direction bit; e.g., 0x81 for IN endpoint 1).
// - `type`: Type of transfer (control, bulk, etc.). If `control`, the data should begin with the 8-byte setup packet.
// - `data`: The payload buffer for the transfer. For control OUT, this includes the setup packet and outgoing data; for control IN, include the setup packet and allocate space for response.
// - `timeout_ms`: Timeout for the transfer in milliseconds (0 for no timeout).
// On success, returns a Transfer handle representing the in-flight transfer. The actual completion (success or error) will be delivered via the event handling mechanism.
extern bool component_usb_device_method_device_handle_new_transfer(component_usb_device_borrow_device_handle_t self, component_usb_device_transfer_type_t xfer_type, component_usb_device_transfer_setup_t *setup, uint32_t buf_size, component_usb_device_transfer_options_t *opts, component_usb_device_own_transfer_t *ret, component_usb_device_libusb_error_t *err);
// Close an open device handle. After this, the handle is invalid.
// This will release any resources allocated for the handle.
// (No error is returned; if the device was already disconnected,
// the handle is simply closed.)
extern void component_usb_device_method_device_handle_close(component_usb_device_borrow_device_handle_t self);
// Initialize the libusb backend.
// This may set up internal data structures or threads.
// Corresponds to libusb_init().
extern bool component_usb_device_init(component_usb_device_libusb_error_t *err);
// Enumerate all USB devices on the system.
// Returns a list of usb-device objects representing each device.
// This corresponds to libusb_get_device_list().
// The returned devices are new references managed by the backend.
extern bool component_usb_device_list_devices(component_usb_device_list_own_usb_device_t *ret, component_usb_device_libusb_error_t *err);

// Imported Functions from `component:usb/usb-hotplug@0.2.1`
extern bool component_usb_usb_hotplug_enable_hotplug(component_usb_usb_hotplug_libusb_error_t *err);
extern void component_usb_usb_hotplug_poll_events(component_usb_usb_hotplug_list_tuple3_event_info_own_usb_device_t *ret);

// Exported Functions from `wasi:cli/run@0.2.5`
bool exports_wasi_cli_run_run(void);

// Helper Functions

extern void component_usb_transfers_transfer_drop_own(component_usb_transfers_own_transfer_t handle);

extern component_usb_transfers_borrow_transfer_t component_usb_transfers_borrow_transfer(component_usb_transfers_own_transfer_t handle);

void cguest_list_u8_free(cguest_list_u8_t *ptr);

void component_usb_transfers_result_void_libusb_error_free(component_usb_transfers_result_void_libusb_error_t *ptr);

void component_usb_transfers_result_list_u8_libusb_error_free(component_usb_transfers_result_list_u8_libusb_error_t *ptr);

void component_usb_configuration_config_value_free(component_usb_configuration_config_value_t *ptr);

void component_usb_device_config_value_free(component_usb_device_config_value_t *ptr);

extern void component_usb_device_usb_device_drop_own(component_usb_device_own_usb_device_t handle);

extern component_usb_device_borrow_usb_device_t component_usb_device_borrow_usb_device(component_usb_device_own_usb_device_t handle);

extern void component_usb_device_device_handle_drop_own(component_usb_device_own_device_handle_t handle);

extern component_usb_device_borrow_device_handle_t component_usb_device_borrow_device_handle(component_usb_device_own_device_handle_t handle);

void component_usb_device_result_own_device_handle_libusb_error_free(component_usb_device_result_own_device_handle_libusb_error_t *ptr);

void component_usb_device_result_configuration_descriptor_libusb_error_free(component_usb_device_result_configuration_descriptor_libusb_error_t *ptr);

void component_usb_device_result_u8_libusb_error_free(component_usb_device_result_u8_libusb_error_t *ptr);

void component_usb_device_result_void_libusb_error_free(component_usb_device_result_void_libusb_error_t *ptr);

void component_usb_device_result_bool_libusb_error_free(component_usb_device_result_bool_libusb_error_t *ptr);

void component_usb_device_result_own_transfer_libusb_error_free(component_usb_device_result_own_transfer_libusb_error_t *ptr);

void component_usb_device_list_own_usb_device_free(component_usb_device_list_own_usb_device_t *ptr);

void component_usb_device_result_list_own_usb_device_libusb_error_free(component_usb_device_result_list_own_usb_device_libusb_error_t *ptr);

void component_usb_usb_hotplug_result_void_libusb_error_free(component_usb_usb_hotplug_result_void_libusb_error_t *ptr);

void component_usb_usb_hotplug_list_tuple3_event_info_own_usb_device_free(component_usb_usb_hotplug_list_tuple3_event_info_own_usb_device_t *ptr);

void exports_wasi_cli_run_result_void_void_free(exports_wasi_cli_run_result_void_void_t *ptr);


#ifdef __cplusplus
}
#endif
#endif
