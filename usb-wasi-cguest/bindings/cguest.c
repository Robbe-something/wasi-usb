// Generated by `wit-bindgen` 0.42.1. DO NOT EDIT!
#include "cguest.h"
#include <stdlib.h>

// Imported Functions from `component:usb/transfers@0.2.1`

__attribute__((__import_module__("component:usb/transfers@0.2.1"), __import_name__("[method]transfer.submit-transfer")))
extern void __wasm_import_component_usb_transfers_method_transfer_submit_transfer(int32_t, uint8_t *, size_t, uint8_t *);

__attribute__((__import_module__("component:usb/transfers@0.2.1"), __import_name__("[method]transfer.cancel-transfer")))
extern void __wasm_import_component_usb_transfers_method_transfer_cancel_transfer(int32_t, uint8_t *);

__attribute__((__import_module__("component:usb/transfers@0.2.1"), __import_name__("await-transfer")))
extern void __wasm_import_component_usb_transfers_await_transfer(int32_t, uint8_t *);

// Imported Functions from `component:usb/device@0.2.1`

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[method]usb-device.open")))
extern void __wasm_import_component_usb_device_method_usb_device_open(int32_t, uint8_t *);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[method]usb-device.get-configuration-descriptor")))
extern void __wasm_import_component_usb_device_method_usb_device_get_configuration_descriptor(int32_t, int32_t, uint8_t *);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[method]usb-device.get-configuration-descriptor-by-value")))
extern void __wasm_import_component_usb_device_method_usb_device_get_configuration_descriptor_by_value(int32_t, int32_t, uint8_t *);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[method]usb-device.get-active-configuration-descriptor")))
extern void __wasm_import_component_usb_device_method_usb_device_get_active_configuration_descriptor(int32_t, uint8_t *);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[method]device-handle.get-configuration")))
extern void __wasm_import_component_usb_device_method_device_handle_get_configuration(int32_t, uint8_t *);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[method]device-handle.set-configuration")))
extern void __wasm_import_component_usb_device_method_device_handle_set_configuration(int32_t, int32_t, int32_t, uint8_t *);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[method]device-handle.claim-interface")))
extern void __wasm_import_component_usb_device_method_device_handle_claim_interface(int32_t, int32_t, uint8_t *);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[method]device-handle.release-interface")))
extern void __wasm_import_component_usb_device_method_device_handle_release_interface(int32_t, int32_t, uint8_t *);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[method]device-handle.set-interface-altsetting")))
extern void __wasm_import_component_usb_device_method_device_handle_set_interface_altsetting(int32_t, int32_t, int32_t, uint8_t *);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[method]device-handle.clear-halt")))
extern void __wasm_import_component_usb_device_method_device_handle_clear_halt(int32_t, int32_t, uint8_t *);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[method]device-handle.reset-device")))
extern void __wasm_import_component_usb_device_method_device_handle_reset_device(int32_t, uint8_t *);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[method]device-handle.alloc-streams")))
extern void __wasm_import_component_usb_device_method_device_handle_alloc_streams(int32_t, int32_t, uint8_t *, size_t, uint8_t *);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[method]device-handle.free-streams")))
extern void __wasm_import_component_usb_device_method_device_handle_free_streams(int32_t, uint8_t *, size_t, uint8_t *);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[method]device-handle.kernel-driver-active")))
extern void __wasm_import_component_usb_device_method_device_handle_kernel_driver_active(int32_t, int32_t, uint8_t *);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[method]device-handle.detach-kernel-driver")))
extern void __wasm_import_component_usb_device_method_device_handle_detach_kernel_driver(int32_t, int32_t, uint8_t *);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[method]device-handle.attach-kernel-driver")))
extern void __wasm_import_component_usb_device_method_device_handle_attach_kernel_driver(int32_t, int32_t, uint8_t *);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[method]device-handle.new-transfer")))
extern void __wasm_import_component_usb_device_method_device_handle_new_transfer(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, uint8_t *);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[method]device-handle.close")))
extern void __wasm_import_component_usb_device_method_device_handle_close(int32_t);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("init")))
extern void __wasm_import_component_usb_device_init(uint8_t *);

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("list-devices")))
extern void __wasm_import_component_usb_device_list_devices(uint8_t *);

// Imported Functions from `component:usb/usb-hotplug@0.2.1`

__attribute__((__import_module__("component:usb/usb-hotplug@0.2.1"), __import_name__("enable-hotplug")))
extern void __wasm_import_component_usb_usb_hotplug_enable_hotplug(uint8_t *);

__attribute__((__import_module__("component:usb/usb-hotplug@0.2.1"), __import_name__("poll-events")))
extern void __wasm_import_component_usb_usb_hotplug_poll_events(uint8_t *);

// Exported Functions from `wasi:cli/run@0.2.5`


// Canonical ABI intrinsics

__attribute__((__weak__, __export_name__("cabi_realloc")))
void *cabi_realloc(void *ptr, size_t old_size, size_t align, size_t new_size) {
  (void) old_size;
  if (new_size == 0) return (void*) align;
  void *ret = realloc(ptr, new_size);
  if (!ret) abort();
  return ret;
}

// Helper Functions

__attribute__((__import_module__("component:usb/transfers@0.2.1"), __import_name__("[resource-drop]transfer")))
extern void __wasm_import_component_usb_transfers_transfer_drop(int32_t handle);

void component_usb_transfers_transfer_drop_own(component_usb_transfers_own_transfer_t handle) {
  __wasm_import_component_usb_transfers_transfer_drop(handle.__handle);
}

component_usb_transfers_borrow_transfer_t component_usb_transfers_borrow_transfer(component_usb_transfers_own_transfer_t arg) {
  return (component_usb_transfers_borrow_transfer_t) { arg.__handle };
}

void cguest_list_u8_free(cguest_list_u8_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    uint8_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
    }
    free(list_ptr);
  }
}

void component_usb_transfers_result_void_libusb_error_free(component_usb_transfers_result_void_libusb_error_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void component_usb_transfers_result_list_u8_libusb_error_free(component_usb_transfers_result_list_u8_libusb_error_t *ptr) {
  if (!ptr->is_err) {
    cguest_list_u8_free(&ptr->val.ok);
  } else {
  }
}

void component_usb_configuration_config_value_free(component_usb_configuration_config_value_t *ptr) {
  switch ((int32_t) ptr->tag) {
    case 1: {
      break;
    }
  }
}

void component_usb_descriptors_list_endpoint_descriptor_free(component_usb_descriptors_list_endpoint_descriptor_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    component_usb_descriptors_endpoint_descriptor_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
    }
    free(list_ptr);
  }
}

void component_usb_descriptors_interface_descriptor_free(component_usb_descriptors_interface_descriptor_t *ptr) {
  component_usb_descriptors_list_endpoint_descriptor_free(&ptr->endpoints);
}

void component_usb_descriptors_list_interface_descriptor_free(component_usb_descriptors_list_interface_descriptor_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    component_usb_descriptors_interface_descriptor_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      component_usb_descriptors_interface_descriptor_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void component_usb_descriptors_configuration_descriptor_free(component_usb_descriptors_configuration_descriptor_t *ptr) {
  component_usb_descriptors_list_interface_descriptor_free(&ptr->interfaces);
}

void component_usb_device_config_value_free(component_usb_device_config_value_t *ptr) {
  component_usb_configuration_config_value_free(ptr);
}

void component_usb_device_configuration_descriptor_free(component_usb_device_configuration_descriptor_t *ptr) {
  component_usb_descriptors_configuration_descriptor_free(ptr);
}

void component_usb_device_interface_descriptor_free(component_usb_device_interface_descriptor_t *ptr) {
  component_usb_descriptors_interface_descriptor_free(ptr);
}

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[resource-drop]usb-device")))
extern void __wasm_import_component_usb_device_usb_device_drop(int32_t handle);

void component_usb_device_usb_device_drop_own(component_usb_device_own_usb_device_t handle) {
  __wasm_import_component_usb_device_usb_device_drop(handle.__handle);
}

component_usb_device_borrow_usb_device_t component_usb_device_borrow_usb_device(component_usb_device_own_usb_device_t arg) {
  return (component_usb_device_borrow_usb_device_t) { arg.__handle };
}

__attribute__((__import_module__("component:usb/device@0.2.1"), __import_name__("[resource-drop]device-handle")))
extern void __wasm_import_component_usb_device_device_handle_drop(int32_t handle);

void component_usb_device_device_handle_drop_own(component_usb_device_own_device_handle_t handle) {
  __wasm_import_component_usb_device_device_handle_drop(handle.__handle);
}

component_usb_device_borrow_device_handle_t component_usb_device_borrow_device_handle(component_usb_device_own_device_handle_t arg) {
  return (component_usb_device_borrow_device_handle_t) { arg.__handle };
}

void component_usb_device_result_own_device_handle_libusb_error_free(component_usb_device_result_own_device_handle_libusb_error_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void component_usb_device_result_configuration_descriptor_libusb_error_free(component_usb_device_result_configuration_descriptor_libusb_error_t *ptr) {
  if (!ptr->is_err) {
    component_usb_device_configuration_descriptor_free(&ptr->val.ok);
  } else {
  }
}

void component_usb_device_result_u8_libusb_error_free(component_usb_device_result_u8_libusb_error_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void component_usb_device_result_void_libusb_error_free(component_usb_device_result_void_libusb_error_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void component_usb_device_result_bool_libusb_error_free(component_usb_device_result_bool_libusb_error_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void component_usb_device_result_own_transfer_libusb_error_free(component_usb_device_result_own_transfer_libusb_error_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void component_usb_device_list_tuple3_own_usb_device_device_descriptor_device_location_free(component_usb_device_list_tuple3_own_usb_device_device_descriptor_device_location_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    component_usb_device_tuple3_own_usb_device_device_descriptor_device_location_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
    }
    free(list_ptr);
  }
}

void component_usb_device_result_list_tuple3_own_usb_device_device_descriptor_device_location_libusb_error_free(component_usb_device_result_list_tuple3_own_usb_device_device_descriptor_device_location_libusb_error_t *ptr) {
  if (!ptr->is_err) {
    component_usb_device_list_tuple3_own_usb_device_device_descriptor_device_location_free(&ptr->val.ok);
  } else {
  }
}

void component_usb_usb_hotplug_result_void_libusb_error_free(component_usb_usb_hotplug_result_void_libusb_error_t *ptr) {
  if (!ptr->is_err) {
  } else {
  }
}

void component_usb_usb_hotplug_list_tuple3_event_info_own_usb_device_free(component_usb_usb_hotplug_list_tuple3_event_info_own_usb_device_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    component_usb_usb_hotplug_tuple3_event_info_own_usb_device_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
    }
    free(list_ptr);
  }
}

void exports_wasi_cli_run_result_void_void_free(exports_wasi_cli_run_result_void_void_t *ptr) {
  if (!ptr->is_err) {
  }
}

// Component Adapters

bool component_usb_transfers_method_transfer_submit_transfer(component_usb_transfers_borrow_transfer_t self, cguest_list_u8_t *data, component_usb_transfers_libusb_error_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_transfers_method_transfer_submit_transfer((self).__handle, (uint8_t *) (*data).ptr, (*data).len, ptr);
  component_usb_transfers_result_void_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + 1));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_transfers_method_transfer_cancel_transfer(component_usb_transfers_borrow_transfer_t self, component_usb_transfers_libusb_error_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_transfers_method_transfer_cancel_transfer((self).__handle, ptr);
  component_usb_transfers_result_void_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + 1));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_transfers_await_transfer(component_usb_transfers_own_transfer_t xfer, cguest_list_u8_t *ret, component_usb_transfers_libusb_error_t *err) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(3*sizeof(void*))];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_transfers_await_transfer((xfer).__handle, ptr);
  component_usb_transfers_result_list_u8_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (cguest_list_u8_t) { (uint8_t*)(*((uint8_t **) (ptr + sizeof(void*)))), (*((size_t*) (ptr + (2*sizeof(void*))))) };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + sizeof(void*)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_device_method_usb_device_open(component_usb_device_borrow_usb_device_t self, component_usb_device_own_device_handle_t *ret, component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_method_usb_device_open((self).__handle, ptr);
  component_usb_device_result_own_device_handle_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (component_usb_device_own_device_handle_t) { *((int32_t*) (ptr + 4)) };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + 4));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_device_method_usb_device_get_configuration_descriptor(component_usb_device_borrow_usb_device_t self, uint8_t config_index, component_usb_device_configuration_descriptor_t *ret, component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(5*sizeof(void*))];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_method_usb_device_get_configuration_descriptor((self).__handle, (int32_t) (config_index), ptr);
  component_usb_device_result_configuration_descriptor_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (component_usb_descriptors_configuration_descriptor_t) {
        (uint8_t) (uint8_t) ((int32_t) *((uint8_t*) (ptr + sizeof(void*)))),
        (uint8_t) (uint8_t) ((int32_t) *((uint8_t*) (ptr + (1+1*sizeof(void*))))),
        (uint16_t) (uint16_t) ((int32_t) *((uint16_t*) (ptr + (2+1*sizeof(void*))))),
        (component_usb_descriptors_list_interface_descriptor_t) (component_usb_descriptors_list_interface_descriptor_t) { (component_usb_descriptors_interface_descriptor_t*)(*((uint8_t **) (ptr + (2*sizeof(void*))))), (*((size_t*) (ptr + (3*sizeof(void*))))) },
        (uint8_t) (uint8_t) ((int32_t) *((uint8_t*) (ptr + (4*sizeof(void*))))),
        (uint8_t) (uint8_t) ((int32_t) *((uint8_t*) (ptr + (1+4*sizeof(void*))))),
        (uint8_t) (uint8_t) ((int32_t) *((uint8_t*) (ptr + (2+4*sizeof(void*))))),
        (uint8_t) (uint8_t) ((int32_t) *((uint8_t*) (ptr + (3+4*sizeof(void*))))),
      };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + sizeof(void*)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_device_method_usb_device_get_configuration_descriptor_by_value(component_usb_device_borrow_usb_device_t self, uint8_t config_value, component_usb_device_configuration_descriptor_t *ret, component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(5*sizeof(void*))];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_method_usb_device_get_configuration_descriptor_by_value((self).__handle, (int32_t) (config_value), ptr);
  component_usb_device_result_configuration_descriptor_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (component_usb_descriptors_configuration_descriptor_t) {
        (uint8_t) (uint8_t) ((int32_t) *((uint8_t*) (ptr + sizeof(void*)))),
        (uint8_t) (uint8_t) ((int32_t) *((uint8_t*) (ptr + (1+1*sizeof(void*))))),
        (uint16_t) (uint16_t) ((int32_t) *((uint16_t*) (ptr + (2+1*sizeof(void*))))),
        (component_usb_descriptors_list_interface_descriptor_t) (component_usb_descriptors_list_interface_descriptor_t) { (component_usb_descriptors_interface_descriptor_t*)(*((uint8_t **) (ptr + (2*sizeof(void*))))), (*((size_t*) (ptr + (3*sizeof(void*))))) },
        (uint8_t) (uint8_t) ((int32_t) *((uint8_t*) (ptr + (4*sizeof(void*))))),
        (uint8_t) (uint8_t) ((int32_t) *((uint8_t*) (ptr + (1+4*sizeof(void*))))),
        (uint8_t) (uint8_t) ((int32_t) *((uint8_t*) (ptr + (2+4*sizeof(void*))))),
        (uint8_t) (uint8_t) ((int32_t) *((uint8_t*) (ptr + (3+4*sizeof(void*))))),
      };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + sizeof(void*)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_device_method_usb_device_get_active_configuration_descriptor(component_usb_device_borrow_usb_device_t self, component_usb_device_configuration_descriptor_t *ret, component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(5*sizeof(void*))];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_method_usb_device_get_active_configuration_descriptor((self).__handle, ptr);
  component_usb_device_result_configuration_descriptor_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (component_usb_descriptors_configuration_descriptor_t) {
        (uint8_t) (uint8_t) ((int32_t) *((uint8_t*) (ptr + sizeof(void*)))),
        (uint8_t) (uint8_t) ((int32_t) *((uint8_t*) (ptr + (1+1*sizeof(void*))))),
        (uint16_t) (uint16_t) ((int32_t) *((uint16_t*) (ptr + (2+1*sizeof(void*))))),
        (component_usb_descriptors_list_interface_descriptor_t) (component_usb_descriptors_list_interface_descriptor_t) { (component_usb_descriptors_interface_descriptor_t*)(*((uint8_t **) (ptr + (2*sizeof(void*))))), (*((size_t*) (ptr + (3*sizeof(void*))))) },
        (uint8_t) (uint8_t) ((int32_t) *((uint8_t*) (ptr + (4*sizeof(void*))))),
        (uint8_t) (uint8_t) ((int32_t) *((uint8_t*) (ptr + (1+4*sizeof(void*))))),
        (uint8_t) (uint8_t) ((int32_t) *((uint8_t*) (ptr + (2+4*sizeof(void*))))),
        (uint8_t) (uint8_t) ((int32_t) *((uint8_t*) (ptr + (3+4*sizeof(void*))))),
      };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + sizeof(void*)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_device_method_device_handle_get_configuration(component_usb_device_borrow_device_handle_t self, uint8_t *ret, component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_method_device_handle_get_configuration((self).__handle, ptr);
  component_usb_device_result_u8_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (uint8_t) ((int32_t) *((uint8_t*) (ptr + 1)));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + 1));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_device_method_device_handle_set_configuration(component_usb_device_borrow_device_handle_t self, component_usb_device_config_value_t *config, component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  int32_t variant;
  int32_t variant1;
  switch ((int32_t) (*config).tag) {
    case 0: {
      variant = 0;
      variant1 = 0;
      break;
    }
    case 1: {
      const uint8_t *payload0 = &(*config).val.value;
      variant = 1;
      variant1 = (int32_t) (*payload0);
      break;
    }
  }
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_method_device_handle_set_configuration((self).__handle, variant, variant1, ptr);
  component_usb_device_result_void_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + 1));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_device_method_device_handle_claim_interface(component_usb_device_borrow_device_handle_t self, uint8_t ifac, component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_method_device_handle_claim_interface((self).__handle, (int32_t) (ifac), ptr);
  component_usb_device_result_void_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + 1));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_device_method_device_handle_release_interface(component_usb_device_borrow_device_handle_t self, uint8_t ifac, component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_method_device_handle_release_interface((self).__handle, (int32_t) (ifac), ptr);
  component_usb_device_result_void_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + 1));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_device_method_device_handle_set_interface_altsetting(component_usb_device_borrow_device_handle_t self, uint8_t ifac, uint8_t alt_setting, component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_method_device_handle_set_interface_altsetting((self).__handle, (int32_t) (ifac), (int32_t) (alt_setting), ptr);
  component_usb_device_result_void_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + 1));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_device_method_device_handle_clear_halt(component_usb_device_borrow_device_handle_t self, uint8_t endpoint, component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_method_device_handle_clear_halt((self).__handle, (int32_t) (endpoint), ptr);
  component_usb_device_result_void_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + 1));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_device_method_device_handle_reset_device(component_usb_device_borrow_device_handle_t self, component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_method_device_handle_reset_device((self).__handle, ptr);
  component_usb_device_result_void_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + 1));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_device_method_device_handle_alloc_streams(component_usb_device_borrow_device_handle_t self, uint32_t num_streams, cguest_list_u8_t *endpoints, component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_method_device_handle_alloc_streams((self).__handle, (int32_t) (num_streams), (uint8_t *) (*endpoints).ptr, (*endpoints).len, ptr);
  component_usb_device_result_void_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + 1));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_device_method_device_handle_free_streams(component_usb_device_borrow_device_handle_t self, cguest_list_u8_t *endpoints, component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_method_device_handle_free_streams((self).__handle, (uint8_t *) (*endpoints).ptr, (*endpoints).len, ptr);
  component_usb_device_result_void_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + 1));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_device_method_device_handle_kernel_driver_active(component_usb_device_borrow_device_handle_t self, uint8_t ifac, bool *ret, component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_method_device_handle_kernel_driver_active((self).__handle, (int32_t) (ifac), ptr);
  component_usb_device_result_bool_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (int32_t) *((uint8_t*) (ptr + 1));
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + 1));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_device_method_device_handle_detach_kernel_driver(component_usb_device_borrow_device_handle_t self, uint8_t ifac, component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_method_device_handle_detach_kernel_driver((self).__handle, (int32_t) (ifac), ptr);
  component_usb_device_result_void_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + 1));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_device_method_device_handle_attach_kernel_driver(component_usb_device_borrow_device_handle_t self, uint8_t ifac, component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_method_device_handle_attach_kernel_driver((self).__handle, (int32_t) (ifac), ptr);
  component_usb_device_result_void_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + 1));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_device_method_device_handle_new_transfer(component_usb_device_borrow_device_handle_t self, component_usb_device_transfer_type_t xfer_type, component_usb_device_transfer_setup_t *setup, uint32_t buf_size, component_usb_device_transfer_options_t *opts, component_usb_device_own_transfer_t *ret, component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(4)))
  uint8_t ret_area[8];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_method_device_handle_new_transfer((self).__handle, (int32_t) xfer_type, (int32_t) ((*setup).bm_request_type), (int32_t) ((*setup).b_request), (int32_t) ((*setup).w_value), (int32_t) ((*setup).w_index), (int32_t) (buf_size), (int32_t) ((*opts).endpoint), (int32_t) ((*opts).timeout_ms), (int32_t) ((*opts).stream_id), (int32_t) ((*opts).iso_packets), ptr);
  component_usb_device_result_own_transfer_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (component_usb_device_own_transfer_t) { *((int32_t*) (ptr + 4)) };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + 4));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

void component_usb_device_method_device_handle_close(component_usb_device_borrow_device_handle_t self) {
  __wasm_import_component_usb_device_method_device_handle_close((self).__handle);
}

bool component_usb_device_init(component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_init(ptr);
  component_usb_device_result_void_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + 1));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_device_list_devices(component_usb_device_list_tuple3_own_usb_device_device_descriptor_device_location_t *ret, component_usb_device_libusb_error_t *err) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(3*sizeof(void*))];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_device_list_devices(ptr);
  component_usb_device_result_list_tuple3_own_usb_device_device_descriptor_device_location_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (component_usb_device_list_tuple3_own_usb_device_device_descriptor_device_location_t) { (component_usb_device_tuple3_own_usb_device_device_descriptor_device_location_t*)(*((uint8_t **) (ptr + sizeof(void*)))), (*((size_t*) (ptr + (2*sizeof(void*))))) };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + sizeof(void*)));
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool component_usb_usb_hotplug_enable_hotplug(component_usb_usb_hotplug_libusb_error_t *err) {
  __attribute__((__aligned__(1)))
  uint8_t ret_area[2];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_usb_hotplug_enable_hotplug(ptr);
  component_usb_usb_hotplug_result_void_libusb_error_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (int32_t) *((uint8_t*) (ptr + 1));
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

void component_usb_usb_hotplug_poll_events(component_usb_usb_hotplug_list_tuple3_event_info_own_usb_device_t *ret) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(2*sizeof(void*))];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_component_usb_usb_hotplug_poll_events(ptr);
  *ret = (component_usb_usb_hotplug_list_tuple3_event_info_own_usb_device_t) { (component_usb_usb_hotplug_tuple3_event_info_own_usb_device_t*)(*((uint8_t **) (ptr + 0))), (*((size_t*) (ptr + sizeof(void*)))) };
}

__attribute__((__export_name__("wasi:cli/run@0.2.5#run")))
int32_t __wasm_export_exports_wasi_cli_run_run(void) {
  exports_wasi_cli_run_result_void_void_t ret;
  ret.is_err = !exports_wasi_cli_run_run();
  int32_t result;
  if ((ret).is_err) {
    result = 1;
  } else {
    result = 0;
  }
  return result;
}

// Ensure that the *_component_type.o object is linked in

extern void __component_type_object_force_link_cguest(void);
void __component_type_object_force_link_cguest_public_use_in_this_compilation_unit(void) {
  __component_type_object_force_link_cguest();
}
